import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export declare namespace IPaymaster {
    type GasAndDataLimitsStruct = {
        acceptanceBudget: BigNumberish;
        preRelayedCallGasLimit: BigNumberish;
        postRelayedCallGasLimit: BigNumberish;
        calldataSizeLimit: BigNumberish;
    };
    type GasAndDataLimitsStructOutput = [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
    ] & {
        acceptanceBudget: BigNumber;
        preRelayedCallGasLimit: BigNumber;
        postRelayedCallGasLimit: BigNumber;
        calldataSizeLimit: BigNumber;
    };
}
export declare namespace IForwarder {
    type ForwardRequestStruct = {
        from: string;
        to: string;
        value: BigNumberish;
        gas: BigNumberish;
        nonce: BigNumberish;
        data: BytesLike;
        validUntilTime: BigNumberish;
    };
    type ForwardRequestStructOutput = [
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        BigNumber
    ] & {
        from: string;
        to: string;
        value: BigNumber;
        gas: BigNumber;
        nonce: BigNumber;
        data: string;
        validUntilTime: BigNumber;
    };
}
export declare namespace GsnTypes {
    type RelayDataStruct = {
        maxFeePerGas: BigNumberish;
        maxPriorityFeePerGas: BigNumberish;
        transactionCalldataGasUsed: BigNumberish;
        relayWorker: string;
        paymaster: string;
        forwarder: string;
        paymasterData: BytesLike;
        clientId: BigNumberish;
    };
    type RelayDataStructOutput = [
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        string,
        string,
        string,
        BigNumber
    ] & {
        maxFeePerGas: BigNumber;
        maxPriorityFeePerGas: BigNumber;
        transactionCalldataGasUsed: BigNumber;
        relayWorker: string;
        paymaster: string;
        forwarder: string;
        paymasterData: string;
        clientId: BigNumber;
    };
    type RelayRequestStruct = {
        request: IForwarder.ForwardRequestStruct;
        relayData: GsnTypes.RelayDataStruct;
    };
    type RelayRequestStructOutput = [
        IForwarder.ForwardRequestStructOutput,
        GsnTypes.RelayDataStructOutput
    ] & {
        request: IForwarder.ForwardRequestStructOutput;
        relayData: GsnTypes.RelayDataStructOutput;
    };
}
export interface IPaymasterInterface extends utils.Interface {
    functions: {
        "supportsInterface(bytes4)": FunctionFragment;
        "getGasAndDataLimits()": FunctionFragment;
        "getTrustedForwarder()": FunctionFragment;
        "getRelayHub()": FunctionFragment;
        "preRelayedCall(((address,address,uint256,uint256,uint256,bytes,uint256),(uint256,uint256,uint256,address,address,address,bytes,uint256)),bytes,bytes,uint256)": FunctionFragment;
        "postRelayedCall(bytes,bool,uint256,(uint256,uint256,uint256,address,address,address,bytes,uint256))": FunctionFragment;
        "versionPaymaster()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "supportsInterface" | "getGasAndDataLimits" | "getTrustedForwarder" | "getRelayHub" | "preRelayedCall" | "postRelayedCall" | "versionPaymaster"): FunctionFragment;
    encodeFunctionData(functionFragment: "supportsInterface", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "getGasAndDataLimits", values?: undefined): string;
    encodeFunctionData(functionFragment: "getTrustedForwarder", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRelayHub", values?: undefined): string;
    encodeFunctionData(functionFragment: "preRelayedCall", values: [GsnTypes.RelayRequestStruct, BytesLike, BytesLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "postRelayedCall", values: [BytesLike, boolean, BigNumberish, GsnTypes.RelayDataStruct]): string;
    encodeFunctionData(functionFragment: "versionPaymaster", values?: undefined): string;
    decodeFunctionResult(functionFragment: "supportsInterface", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getGasAndDataLimits", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getTrustedForwarder", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRelayHub", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "preRelayedCall", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "postRelayedCall", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "versionPaymaster", data: BytesLike): Result;
    events: {};
}
export interface IPaymaster extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: IPaymasterInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        /**
         * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
         */
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<[boolean]>;
        /**
         * Return the Gas Limits for Paymaster's functions and maximum msg.data length values for this Paymaster. This function allows different paymasters to have different properties without changes to the RelayHub.
         */
        getGasAndDataLimits(overrides?: CallOverrides): Promise<[
            IPaymaster.GasAndDataLimitsStructOutput
        ] & {
            limits: IPaymaster.GasAndDataLimitsStructOutput;
        }>;
        /**
         * :warning: **Warning** :warning: using incorrect Forwarder may cause the Paymaster to agreeing to pay for invalid transactions.
         */
        getTrustedForwarder(overrides?: CallOverrides): Promise<[string] & {
            trustedForwarder: string;
        }>;
        /**
         */
        getRelayHub(overrides?: CallOverrides): Promise<[string] & {
            relayHub: string;
        }>;
        preRelayedCall(relayRequest: GsnTypes.RelayRequestStruct, signature: BytesLike, approvalData: BytesLike, maxPossibleGas: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        postRelayedCall(context: BytesLike, success: boolean, gasUseWithoutPost: BigNumberish, relayData: GsnTypes.RelayDataStruct, overrides?: Overrides & {
            from?: string;
        }): Promise<ContractTransaction>;
        /**
         */
        versionPaymaster(overrides?: CallOverrides): Promise<[string]>;
    };
    /**
     * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
     */
    supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;
    /**
     * Return the Gas Limits for Paymaster's functions and maximum msg.data length values for this Paymaster. This function allows different paymasters to have different properties without changes to the RelayHub.
     */
    getGasAndDataLimits(overrides?: CallOverrides): Promise<IPaymaster.GasAndDataLimitsStructOutput>;
    /**
     * :warning: **Warning** :warning: using incorrect Forwarder may cause the Paymaster to agreeing to pay for invalid transactions.
     */
    getTrustedForwarder(overrides?: CallOverrides): Promise<string>;
    /**
     */
    getRelayHub(overrides?: CallOverrides): Promise<string>;
    preRelayedCall(relayRequest: GsnTypes.RelayRequestStruct, signature: BytesLike, approvalData: BytesLike, maxPossibleGas: BigNumberish, overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    postRelayedCall(context: BytesLike, success: boolean, gasUseWithoutPost: BigNumberish, relayData: GsnTypes.RelayDataStruct, overrides?: Overrides & {
        from?: string;
    }): Promise<ContractTransaction>;
    /**
     */
    versionPaymaster(overrides?: CallOverrides): Promise<string>;
    callStatic: {
        /**
         * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
         */
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;
        /**
         * Return the Gas Limits for Paymaster's functions and maximum msg.data length values for this Paymaster. This function allows different paymasters to have different properties without changes to the RelayHub.
         */
        getGasAndDataLimits(overrides?: CallOverrides): Promise<IPaymaster.GasAndDataLimitsStructOutput>;
        /**
         * :warning: **Warning** :warning: using incorrect Forwarder may cause the Paymaster to agreeing to pay for invalid transactions.
         */
        getTrustedForwarder(overrides?: CallOverrides): Promise<string>;
        /**
         */
        getRelayHub(overrides?: CallOverrides): Promise<string>;
        preRelayedCall(relayRequest: GsnTypes.RelayRequestStruct, signature: BytesLike, approvalData: BytesLike, maxPossibleGas: BigNumberish, overrides?: CallOverrides): Promise<[
            string,
            boolean
        ] & {
            context: string;
            rejectOnRecipientRevert: boolean;
        }>;
        postRelayedCall(context: BytesLike, success: boolean, gasUseWithoutPost: BigNumberish, relayData: GsnTypes.RelayDataStruct, overrides?: CallOverrides): Promise<void>;
        /**
         */
        versionPaymaster(overrides?: CallOverrides): Promise<string>;
    };
    filters: {};
    estimateGas: {
        /**
         * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
         */
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * Return the Gas Limits for Paymaster's functions and maximum msg.data length values for this Paymaster. This function allows different paymasters to have different properties without changes to the RelayHub.
         */
        getGasAndDataLimits(overrides?: CallOverrides): Promise<BigNumber>;
        /**
         * :warning: **Warning** :warning: using incorrect Forwarder may cause the Paymaster to agreeing to pay for invalid transactions.
         */
        getTrustedForwarder(overrides?: CallOverrides): Promise<BigNumber>;
        /**
         */
        getRelayHub(overrides?: CallOverrides): Promise<BigNumber>;
        preRelayedCall(relayRequest: GsnTypes.RelayRequestStruct, signature: BytesLike, approvalData: BytesLike, maxPossibleGas: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        postRelayedCall(context: BytesLike, success: boolean, gasUseWithoutPost: BigNumberish, relayData: GsnTypes.RelayDataStruct, overrides?: Overrides & {
            from?: string;
        }): Promise<BigNumber>;
        /**
         */
        versionPaymaster(overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        /**
         * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
         */
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * Return the Gas Limits for Paymaster's functions and maximum msg.data length values for this Paymaster. This function allows different paymasters to have different properties without changes to the RelayHub.
         */
        getGasAndDataLimits(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         * :warning: **Warning** :warning: using incorrect Forwarder may cause the Paymaster to agreeing to pay for invalid transactions.
         */
        getTrustedForwarder(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        /**
         */
        getRelayHub(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        preRelayedCall(relayRequest: GsnTypes.RelayRequestStruct, signature: BytesLike, approvalData: BytesLike, maxPossibleGas: BigNumberish, overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        postRelayedCall(context: BytesLike, success: boolean, gasUseWithoutPost: BigNumberish, relayData: GsnTypes.RelayDataStruct, overrides?: Overrides & {
            from?: string;
        }): Promise<PopulatedTransaction>;
        /**
         */
        versionPaymaster(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}
