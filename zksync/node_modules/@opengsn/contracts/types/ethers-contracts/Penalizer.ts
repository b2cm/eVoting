/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace IPenalizer {
  export type TransactionStruct = {
    nonce: BigNumberish;
    gasLimit: BigNumberish;
    to: string;
    value: BigNumberish;
    data: BytesLike;
  };

  export type TransactionStructOutput = [
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    string
  ] & {
    nonce: BigNumber;
    gasLimit: BigNumber;
    to: string;
    value: BigNumber;
    data: string;
  };
}

export interface PenalizerInterface extends utils.Interface {
  functions: {
    "commits(bytes32)": FunctionFragment;
    "versionPenalizer()": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "getPenalizeBlockDelay()": FunctionFragment;
    "getPenalizeBlockExpiration()": FunctionFragment;
    "isTransactionTypeValid(bytes)": FunctionFragment;
    "decodeTransaction(bytes)": FunctionFragment;
    "commit(bytes32)": FunctionFragment;
    "penalizeRepeatedNonce(bytes,bytes,bytes,bytes,address,uint256)": FunctionFragment;
    "penalizeIllegalTransaction(bytes,bytes,address,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "commits"
      | "versionPenalizer"
      | "supportsInterface"
      | "getPenalizeBlockDelay"
      | "getPenalizeBlockExpiration"
      | "isTransactionTypeValid"
      | "decodeTransaction"
      | "commit"
      | "penalizeRepeatedNonce"
      | "penalizeIllegalTransaction"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "commits", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "versionPenalizer",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getPenalizeBlockDelay",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPenalizeBlockExpiration",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isTransactionTypeValid",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "decodeTransaction",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "commit", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "penalizeRepeatedNonce",
    values: [BytesLike, BytesLike, BytesLike, BytesLike, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "penalizeIllegalTransaction",
    values: [BytesLike, BytesLike, string, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "commits", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "versionPenalizer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPenalizeBlockDelay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPenalizeBlockExpiration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isTransactionTypeValid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "decodeTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "commit", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "penalizeRepeatedNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "penalizeIllegalTransaction",
    data: BytesLike
  ): Result;

  events: {
    "CommitAdded(address,bytes32,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "CommitAdded"): EventFragment;
}

export interface CommitAddedEventObject {
  sender: string;
  commitHash: string;
  readyBlockNumber: BigNumber;
}
export type CommitAddedEvent = TypedEvent<
  [string, string, BigNumber],
  CommitAddedEventObject
>;

export type CommitAddedEventFilter = TypedEventFilter<CommitAddedEvent>;

export interface Penalizer extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: PenalizerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    commits(arg0: BytesLike, overrides?: CallOverrides): Promise<[BigNumber]>;

    versionPenalizer(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     */
    getPenalizeBlockDelay(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     */
    getPenalizeBlockExpiration(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     */
    isTransactionTypeValid(
      rawTransaction: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     */
    decodeTransaction(
      rawTransaction: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [IPenalizer.TransactionStructOutput] & {
        transaction: IPenalizer.TransactionStructOutput;
      }
    >;

    /**
     * Called by the reporter as the first step in the commit-reveal process. Any sender can call it to make sure no-one can front-run it to claim this penalization.
     * @param commitHash The hash of the report of a penalizable behaviour the reporter wants to reveal. Calculated as `commit(keccak(encodedPenalizeFunction))`.
     */
    commit(
      commitHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Called by the reporter as the second step in the commit-reveal process. If a Relay Worker attacked the system by signing multiple transactions with same nonce so only one is accepted, anyone can grab both transactions from the blockchain and submit them here. Check whether `unsignedTx1` != `unsignedTx2`, that both are signed by the same address, and that `unsignedTx1.nonce` == `unsignedTx2.nonce`. If all conditions are met, relay is considered an "offending relay". The offending relay will be unregistered immediately, its stake will be forfeited and given to the address who reported it (the `msg.sender`), thus incentivizing anyone to report offending relays.
     */
    penalizeRepeatedNonce(
      unsignedTx1: BytesLike,
      signature1: BytesLike,
      unsignedTx2: BytesLike,
      signature2: BytesLike,
      hub: string,
      randomValue: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Called by the reporter as the second step in the commit-reveal process. The Relay Workers are not allowed to make calls other than to the `relayCall` method.
     */
    penalizeIllegalTransaction(
      unsignedTx: BytesLike,
      signature: BytesLike,
      hub: string,
      randomValue: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  commits(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

  versionPenalizer(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
   */
  supportsInterface(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   */
  getPenalizeBlockDelay(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   */
  getPenalizeBlockExpiration(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   */
  isTransactionTypeValid(
    rawTransaction: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   */
  decodeTransaction(
    rawTransaction: BytesLike,
    overrides?: CallOverrides
  ): Promise<IPenalizer.TransactionStructOutput>;

  /**
   * Called by the reporter as the first step in the commit-reveal process. Any sender can call it to make sure no-one can front-run it to claim this penalization.
   * @param commitHash The hash of the report of a penalizable behaviour the reporter wants to reveal. Calculated as `commit(keccak(encodedPenalizeFunction))`.
   */
  commit(
    commitHash: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Called by the reporter as the second step in the commit-reveal process. If a Relay Worker attacked the system by signing multiple transactions with same nonce so only one is accepted, anyone can grab both transactions from the blockchain and submit them here. Check whether `unsignedTx1` != `unsignedTx2`, that both are signed by the same address, and that `unsignedTx1.nonce` == `unsignedTx2.nonce`. If all conditions are met, relay is considered an "offending relay". The offending relay will be unregistered immediately, its stake will be forfeited and given to the address who reported it (the `msg.sender`), thus incentivizing anyone to report offending relays.
   */
  penalizeRepeatedNonce(
    unsignedTx1: BytesLike,
    signature1: BytesLike,
    unsignedTx2: BytesLike,
    signature2: BytesLike,
    hub: string,
    randomValue: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Called by the reporter as the second step in the commit-reveal process. The Relay Workers are not allowed to make calls other than to the `relayCall` method.
   */
  penalizeIllegalTransaction(
    unsignedTx: BytesLike,
    signature: BytesLike,
    hub: string,
    randomValue: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    commits(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    versionPenalizer(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     */
    getPenalizeBlockDelay(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     */
    getPenalizeBlockExpiration(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     */
    isTransactionTypeValid(
      rawTransaction: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     */
    decodeTransaction(
      rawTransaction: BytesLike,
      overrides?: CallOverrides
    ): Promise<IPenalizer.TransactionStructOutput>;

    /**
     * Called by the reporter as the first step in the commit-reveal process. Any sender can call it to make sure no-one can front-run it to claim this penalization.
     * @param commitHash The hash of the report of a penalizable behaviour the reporter wants to reveal. Calculated as `commit(keccak(encodedPenalizeFunction))`.
     */
    commit(commitHash: BytesLike, overrides?: CallOverrides): Promise<void>;

    /**
     * Called by the reporter as the second step in the commit-reveal process. If a Relay Worker attacked the system by signing multiple transactions with same nonce so only one is accepted, anyone can grab both transactions from the blockchain and submit them here. Check whether `unsignedTx1` != `unsignedTx2`, that both are signed by the same address, and that `unsignedTx1.nonce` == `unsignedTx2.nonce`. If all conditions are met, relay is considered an "offending relay". The offending relay will be unregistered immediately, its stake will be forfeited and given to the address who reported it (the `msg.sender`), thus incentivizing anyone to report offending relays.
     */
    penalizeRepeatedNonce(
      unsignedTx1: BytesLike,
      signature1: BytesLike,
      unsignedTx2: BytesLike,
      signature2: BytesLike,
      hub: string,
      randomValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Called by the reporter as the second step in the commit-reveal process. The Relay Workers are not allowed to make calls other than to the `relayCall` method.
     */
    penalizeIllegalTransaction(
      unsignedTx: BytesLike,
      signature: BytesLike,
      hub: string,
      randomValue: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "CommitAdded(address,bytes32,uint256)"(
      sender?: string | null,
      commitHash?: BytesLike | null,
      readyBlockNumber?: null
    ): CommitAddedEventFilter;
    CommitAdded(
      sender?: string | null,
      commitHash?: BytesLike | null,
      readyBlockNumber?: null
    ): CommitAddedEventFilter;
  };

  estimateGas: {
    commits(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    versionPenalizer(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     */
    getPenalizeBlockDelay(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     */
    getPenalizeBlockExpiration(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     */
    isTransactionTypeValid(
      rawTransaction: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     */
    decodeTransaction(
      rawTransaction: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Called by the reporter as the first step in the commit-reveal process. Any sender can call it to make sure no-one can front-run it to claim this penalization.
     * @param commitHash The hash of the report of a penalizable behaviour the reporter wants to reveal. Calculated as `commit(keccak(encodedPenalizeFunction))`.
     */
    commit(
      commitHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Called by the reporter as the second step in the commit-reveal process. If a Relay Worker attacked the system by signing multiple transactions with same nonce so only one is accepted, anyone can grab both transactions from the blockchain and submit them here. Check whether `unsignedTx1` != `unsignedTx2`, that both are signed by the same address, and that `unsignedTx1.nonce` == `unsignedTx2.nonce`. If all conditions are met, relay is considered an "offending relay". The offending relay will be unregistered immediately, its stake will be forfeited and given to the address who reported it (the `msg.sender`), thus incentivizing anyone to report offending relays.
     */
    penalizeRepeatedNonce(
      unsignedTx1: BytesLike,
      signature1: BytesLike,
      unsignedTx2: BytesLike,
      signature2: BytesLike,
      hub: string,
      randomValue: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Called by the reporter as the second step in the commit-reveal process. The Relay Workers are not allowed to make calls other than to the `relayCall` method.
     */
    penalizeIllegalTransaction(
      unsignedTx: BytesLike,
      signature: BytesLike,
      hub: string,
      randomValue: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    commits(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    versionPenalizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     */
    getPenalizeBlockDelay(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     */
    getPenalizeBlockExpiration(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     */
    isTransactionTypeValid(
      rawTransaction: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     */
    decodeTransaction(
      rawTransaction: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Called by the reporter as the first step in the commit-reveal process. Any sender can call it to make sure no-one can front-run it to claim this penalization.
     * @param commitHash The hash of the report of a penalizable behaviour the reporter wants to reveal. Calculated as `commit(keccak(encodedPenalizeFunction))`.
     */
    commit(
      commitHash: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Called by the reporter as the second step in the commit-reveal process. If a Relay Worker attacked the system by signing multiple transactions with same nonce so only one is accepted, anyone can grab both transactions from the blockchain and submit them here. Check whether `unsignedTx1` != `unsignedTx2`, that both are signed by the same address, and that `unsignedTx1.nonce` == `unsignedTx2.nonce`. If all conditions are met, relay is considered an "offending relay". The offending relay will be unregistered immediately, its stake will be forfeited and given to the address who reported it (the `msg.sender`), thus incentivizing anyone to report offending relays.
     */
    penalizeRepeatedNonce(
      unsignedTx1: BytesLike,
      signature1: BytesLike,
      unsignedTx2: BytesLike,
      signature2: BytesLike,
      hub: string,
      randomValue: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Called by the reporter as the second step in the commit-reveal process. The Relay Workers are not allowed to make calls other than to the `relayCall` method.
     */
    penalizeIllegalTransaction(
      unsignedTx: BytesLike,
      signature: BytesLike,
      hub: string,
      randomValue: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
