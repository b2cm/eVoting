/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace IRelayHub {
  export type RelayHubConfigStruct = {
    maxWorkerCount: BigNumberish;
    gasReserve: BigNumberish;
    postOverhead: BigNumberish;
    gasOverhead: BigNumberish;
    minimumUnstakeDelay: BigNumberish;
    devAddress: string;
    devFee: BigNumberish;
    baseRelayFee: BigNumberish;
    pctRelayFee: BigNumberish;
  };

  export type RelayHubConfigStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    number,
    BigNumber,
    number
  ] & {
    maxWorkerCount: BigNumber;
    gasReserve: BigNumber;
    postOverhead: BigNumber;
    gasOverhead: BigNumber;
    minimumUnstakeDelay: BigNumber;
    devAddress: string;
    devFee: number;
    baseRelayFee: BigNumber;
    pctRelayFee: number;
  };
}

export declare namespace GsnTypes {
  export type RelayDataStruct = {
    maxFeePerGas: BigNumberish;
    maxPriorityFeePerGas: BigNumberish;
    transactionCalldataGasUsed: BigNumberish;
    relayWorker: string;
    paymaster: string;
    forwarder: string;
    paymasterData: BytesLike;
    clientId: BigNumberish;
  };

  export type RelayDataStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    string,
    string,
    string,
    BigNumber
  ] & {
    maxFeePerGas: BigNumber;
    maxPriorityFeePerGas: BigNumber;
    transactionCalldataGasUsed: BigNumber;
    relayWorker: string;
    paymaster: string;
    forwarder: string;
    paymasterData: string;
    clientId: BigNumber;
  };

  export type RelayRequestStruct = {
    request: IForwarder.ForwardRequestStruct;
    relayData: GsnTypes.RelayDataStruct;
  };

  export type RelayRequestStructOutput = [
    IForwarder.ForwardRequestStructOutput,
    GsnTypes.RelayDataStructOutput
  ] & {
    request: IForwarder.ForwardRequestStructOutput;
    relayData: GsnTypes.RelayDataStructOutput;
  };
}

export declare namespace IForwarder {
  export type ForwardRequestStruct = {
    from: string;
    to: string;
    value: BigNumberish;
    gas: BigNumberish;
    nonce: BigNumberish;
    data: BytesLike;
    validUntilTime: BigNumberish;
  };

  export type ForwardRequestStructOutput = [
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    BigNumber
  ] & {
    from: string;
    to: string;
    value: BigNumber;
    gas: BigNumber;
    nonce: BigNumber;
    data: string;
    validUntilTime: BigNumber;
  };
}

export declare namespace IPaymaster {
  export type GasAndDataLimitsStruct = {
    acceptanceBudget: BigNumberish;
    preRelayedCallGasLimit: BigNumberish;
    postRelayedCallGasLimit: BigNumberish;
    calldataSizeLimit: BigNumberish;
  };

  export type GasAndDataLimitsStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    acceptanceBudget: BigNumber;
    preRelayedCallGasLimit: BigNumber;
    postRelayedCallGasLimit: BigNumber;
    calldataSizeLimit: BigNumber;
  };
}

export interface ArbRelayHubInterface extends utils.Interface {
  functions: {
    "addRelayWorkers(address[])": FunctionFragment;
    "arbsys()": FunctionFragment;
    "balanceOf(address)": FunctionFragment;
    "calculateCharge(uint256,(uint256,uint256,uint256,address,address,address,bytes,uint256))": FunctionFragment;
    "calculateDevCharge(uint256)": FunctionFragment;
    "depositFor(address)": FunctionFragment;
    "deprecateHub(uint256)": FunctionFragment;
    "escheatAbandonedRelayBalance(address)": FunctionFragment;
    "getBatchGateway()": FunctionFragment;
    "getConfiguration()": FunctionFragment;
    "getDeprecationTime()": FunctionFragment;
    "getMinimumStakePerToken(address)": FunctionFragment;
    "getPenalizer()": FunctionFragment;
    "getRelayRegistrar()": FunctionFragment;
    "getStakeManager()": FunctionFragment;
    "getWorkerCount(address)": FunctionFragment;
    "getWorkerManager(address)": FunctionFragment;
    "innerRelayCall(string,((address,address,uint256,uint256,uint256,bytes,uint256),(uint256,uint256,uint256,address,address,address,bytes,uint256)),bytes,bytes,(uint256,uint256,uint256,uint256),uint256,uint256)": FunctionFragment;
    "isDeprecated()": FunctionFragment;
    "isRelayEscheatable(address)": FunctionFragment;
    "onRelayServerRegistered(address)": FunctionFragment;
    "owner()": FunctionFragment;
    "penalize(address,address)": FunctionFragment;
    "relayCall(string,uint256,((address,address,uint256,uint256,uint256,bytes,uint256),(uint256,uint256,uint256,address,address,address,bytes,uint256)),bytes,bytes)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "setConfiguration((uint256,uint256,uint256,uint256,uint256,address,uint8,uint80,uint16))": FunctionFragment;
    "setMinimumStakes(address[],uint256[])": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "verifyRelayManagerStaked(address)": FunctionFragment;
    "withdraw(address,uint256)": FunctionFragment;
    "withdrawMultiple(address[],uint256[])": FunctionFragment;
    "versionHub()": FunctionFragment;
    "getCreationBlock()": FunctionFragment;
    "getL1CreationBlock()": FunctionFragment;
    "aggregateGasleft()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "addRelayWorkers"
      | "arbsys"
      | "balanceOf"
      | "calculateCharge"
      | "calculateDevCharge"
      | "depositFor"
      | "deprecateHub"
      | "escheatAbandonedRelayBalance"
      | "getBatchGateway"
      | "getConfiguration"
      | "getDeprecationTime"
      | "getMinimumStakePerToken"
      | "getPenalizer"
      | "getRelayRegistrar"
      | "getStakeManager"
      | "getWorkerCount"
      | "getWorkerManager"
      | "innerRelayCall"
      | "isDeprecated"
      | "isRelayEscheatable"
      | "onRelayServerRegistered"
      | "owner"
      | "penalize"
      | "relayCall"
      | "renounceOwnership"
      | "setConfiguration"
      | "setMinimumStakes"
      | "supportsInterface"
      | "transferOwnership"
      | "verifyRelayManagerStaked"
      | "withdraw"
      | "withdrawMultiple"
      | "versionHub"
      | "getCreationBlock"
      | "getL1CreationBlock"
      | "aggregateGasleft"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "addRelayWorkers",
    values: [string[]]
  ): string;
  encodeFunctionData(functionFragment: "arbsys", values?: undefined): string;
  encodeFunctionData(functionFragment: "balanceOf", values: [string]): string;
  encodeFunctionData(
    functionFragment: "calculateCharge",
    values: [BigNumberish, GsnTypes.RelayDataStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateDevCharge",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "depositFor", values: [string]): string;
  encodeFunctionData(
    functionFragment: "deprecateHub",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "escheatAbandonedRelayBalance",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getBatchGateway",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getConfiguration",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getDeprecationTime",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getMinimumStakePerToken",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getPenalizer",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getRelayRegistrar",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getStakeManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getWorkerCount",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getWorkerManager",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "innerRelayCall",
    values: [
      string,
      GsnTypes.RelayRequestStruct,
      BytesLike,
      BytesLike,
      IPaymaster.GasAndDataLimitsStruct,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isDeprecated",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isRelayEscheatable",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "onRelayServerRegistered",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "penalize",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "relayCall",
    values: [
      string,
      BigNumberish,
      GsnTypes.RelayRequestStruct,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setConfiguration",
    values: [IRelayHub.RelayHubConfigStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "setMinimumStakes",
    values: [string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyRelayManagerStaked",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawMultiple",
    values: [string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "versionHub",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCreationBlock",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getL1CreationBlock",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "aggregateGasleft",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "addRelayWorkers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "arbsys", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "balanceOf", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "calculateCharge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateDevCharge",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "depositFor", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "deprecateHub",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "escheatAbandonedRelayBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBatchGateway",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getConfiguration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDeprecationTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMinimumStakePerToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPenalizer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRelayRegistrar",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStakeManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getWorkerCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getWorkerManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "innerRelayCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isDeprecated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isRelayEscheatable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onRelayServerRegistered",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "penalize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "relayCall", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setConfiguration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMinimumStakes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyRelayManagerStaked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawMultiple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "versionHub", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCreationBlock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getL1CreationBlock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "aggregateGasleft",
    data: BytesLike
  ): Result;

  events: {
    "AbandonedRelayManagerBalanceEscheated(address,uint256)": EventFragment;
    "Deposited(address,address,uint256)": EventFragment;
    "HubDeprecated(uint256)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "RelayHubConfigured((uint256,uint256,uint256,uint256,uint256,address,uint8,uint80,uint16))": EventFragment;
    "RelayWorkersAdded(address,address[],uint256)": EventFragment;
    "StakingTokenDataChanged(address,uint256)": EventFragment;
    "TransactionRejectedByPaymaster(address,address,bytes32,address,address,address,bytes4,uint256,bytes)": EventFragment;
    "TransactionRelayed(address,address,bytes32,address,address,address,bytes4,uint8,uint256)": EventFragment;
    "TransactionResult(uint8,bytes)": EventFragment;
    "Withdrawn(address,address,uint256)": EventFragment;
  };

  getEvent(
    nameOrSignatureOrTopic: "AbandonedRelayManagerBalanceEscheated"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Deposited"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HubDeprecated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RelayHubConfigured"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RelayWorkersAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakingTokenDataChanged"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "TransactionRejectedByPaymaster"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransactionRelayed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransactionResult"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdrawn"): EventFragment;
}

export interface AbandonedRelayManagerBalanceEscheatedEventObject {
  relayManager: string;
  balance: BigNumber;
}
export type AbandonedRelayManagerBalanceEscheatedEvent = TypedEvent<
  [string, BigNumber],
  AbandonedRelayManagerBalanceEscheatedEventObject
>;

export type AbandonedRelayManagerBalanceEscheatedEventFilter =
  TypedEventFilter<AbandonedRelayManagerBalanceEscheatedEvent>;

export interface DepositedEventObject {
  paymaster: string;
  from: string;
  amount: BigNumber;
}
export type DepositedEvent = TypedEvent<
  [string, string, BigNumber],
  DepositedEventObject
>;

export type DepositedEventFilter = TypedEventFilter<DepositedEvent>;

export interface HubDeprecatedEventObject {
  deprecationTime: BigNumber;
}
export type HubDeprecatedEvent = TypedEvent<
  [BigNumber],
  HubDeprecatedEventObject
>;

export type HubDeprecatedEventFilter = TypedEventFilter<HubDeprecatedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface RelayHubConfiguredEventObject {
  config: IRelayHub.RelayHubConfigStructOutput;
}
export type RelayHubConfiguredEvent = TypedEvent<
  [IRelayHub.RelayHubConfigStructOutput],
  RelayHubConfiguredEventObject
>;

export type RelayHubConfiguredEventFilter =
  TypedEventFilter<RelayHubConfiguredEvent>;

export interface RelayWorkersAddedEventObject {
  relayManager: string;
  newRelayWorkers: string[];
  workersCount: BigNumber;
}
export type RelayWorkersAddedEvent = TypedEvent<
  [string, string[], BigNumber],
  RelayWorkersAddedEventObject
>;

export type RelayWorkersAddedEventFilter =
  TypedEventFilter<RelayWorkersAddedEvent>;

export interface StakingTokenDataChangedEventObject {
  token: string;
  minimumStake: BigNumber;
}
export type StakingTokenDataChangedEvent = TypedEvent<
  [string, BigNumber],
  StakingTokenDataChangedEventObject
>;

export type StakingTokenDataChangedEventFilter =
  TypedEventFilter<StakingTokenDataChangedEvent>;

export interface TransactionRejectedByPaymasterEventObject {
  relayManager: string;
  paymaster: string;
  relayRequestID: string;
  from: string;
  to: string;
  relayWorker: string;
  selector: string;
  innerGasUsed: BigNumber;
  reason: string;
}
export type TransactionRejectedByPaymasterEvent = TypedEvent<
  [string, string, string, string, string, string, string, BigNumber, string],
  TransactionRejectedByPaymasterEventObject
>;

export type TransactionRejectedByPaymasterEventFilter =
  TypedEventFilter<TransactionRejectedByPaymasterEvent>;

export interface TransactionRelayedEventObject {
  relayManager: string;
  relayWorker: string;
  relayRequestID: string;
  from: string;
  to: string;
  paymaster: string;
  selector: string;
  status: number;
  charge: BigNumber;
}
export type TransactionRelayedEvent = TypedEvent<
  [string, string, string, string, string, string, string, number, BigNumber],
  TransactionRelayedEventObject
>;

export type TransactionRelayedEventFilter =
  TypedEventFilter<TransactionRelayedEvent>;

export interface TransactionResultEventObject {
  status: number;
  returnValue: string;
}
export type TransactionResultEvent = TypedEvent<
  [number, string],
  TransactionResultEventObject
>;

export type TransactionResultEventFilter =
  TypedEventFilter<TransactionResultEvent>;

export interface WithdrawnEventObject {
  account: string;
  dest: string;
  amount: BigNumber;
}
export type WithdrawnEvent = TypedEvent<
  [string, string, BigNumber],
  WithdrawnEventObject
>;

export type WithdrawnEventFilter = TypedEventFilter<WithdrawnEvent>;

export interface ArbRelayHub extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ArbRelayHubInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Add new worker addresses controlled by the sender who must be a staked Relay Manager address. Emits a `RelayWorkersAdded` event. This function can be called multiple times, emitting new events.
     */
    addRelayWorkers(
      newRelayWorkers: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    arbsys(overrides?: CallOverrides): Promise<[string]>;

    /**
     */
    balanceOf(target: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    calculateCharge(
      gasUsed: BigNumberish,
      relayData: GsnTypes.RelayDataStruct,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * The fee is expressed as a  percentage of the actual charge. For example, a value '40' stands for a 40% fee, so the Relay Manager will only get 60% of the `charge`.
     * @param charge The amount of Ether in wei the Paymaster will be charged for this transaction.
     */
    calculateDevCharge(
      charge: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * Deposits ether for a `Paymaster`, so that it can and pay for relayed transactions. :warning: **Warning** :warning: Unused balance can only be withdrawn by the holder itself, by calling `withdraw`. Emits a `Deposited` event.
     */
    depositFor(
      target: string,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Deprecate hub by reverting all incoming `relayCall()` calls starting from a given timestamp
     * @param _deprecationTime The timestamp in seconds after which the `RelayHub` stops serving transactions.
     */
    deprecateHub(
      _deprecationTime: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * @param relayManager
     */
    escheatAbandonedRelayBalance(
      relayManager: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     */
    getBatchGateway(overrides?: CallOverrides): Promise<[string]>;

    /**
     */
    getConfiguration(
      overrides?: CallOverrides
    ): Promise<[IRelayHub.RelayHubConfigStructOutput]>;

    /**
     */
    getDeprecationTime(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * @param token An address of an ERC-20 compatible tokens.
     */
    getMinimumStakePerToken(
      token: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     */
    getPenalizer(overrides?: CallOverrides): Promise<[string]>;

    /**
     */
    getRelayRegistrar(overrides?: CallOverrides): Promise<[string]>;

    /**
     */
    getStakeManager(overrides?: CallOverrides): Promise<[string]>;

    /**
     * @param manager An address of the Relay Manager.
     */
    getWorkerCount(
      manager: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    /**
     * @param worker An address of the Relay Worker.
     */
    getWorkerManager(
      worker: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    innerRelayCall(
      domainSeparatorName: string,
      relayRequest: GsnTypes.RelayRequestStruct,
      signature: BytesLike,
      approvalData: BytesLike,
      gasAndDataLimits: IPaymaster.GasAndDataLimitsStruct,
      totalInitialGas: BigNumberish,
      maxPossibleGas: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     */
    isDeprecated(overrides?: CallOverrides): Promise<[boolean]>;

    /**
     * Uses `StakeManager` to check if the Relay Manager can be considered abandoned or not. Returns true if the stake's abandonment time is in the past including the escheatment delay, false otherwise.
     */
    isRelayEscheatable(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * The `RelayRegistrar` callback to notify the `RelayHub` that this `relayManager` has updated registration.
     */
    onRelayServerRegistered(
      relayManager: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<[string]>;

    /**
     * In case the Relay Worker has been found to be in violation of some rules by the `Penalizer` contract, the `Penalizer` will call this method to execute a penalization. The `RelayHub` will look up the Relay Manager of the given Relay Worker and will forward the call to the `StakeManager` contract. The `RelayHub` does not perform the actual penalization either.
     * @param beneficiary The address that called the `Penalizer` and will receive a reward for it.
     * @param relayWorker The address of the Relay Worker that committed a penalizable offense.
     */
    penalize(
      relayWorker: string,
      beneficiary: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    relayCall(
      domainSeparatorName: string,
      maxAcceptanceBudget: BigNumberish,
      relayRequest: GsnTypes.RelayRequestStruct,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setConfiguration(
      _config: IRelayHub.RelayHubConfigStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets or changes the minimum amount of a given `token` that needs to be staked so that the Relay Manager is considered to be 'staked' by this `RelayHub`. Zero value means this token is not allowed for staking.
     * @param minimumStake An array of minimal amounts necessary for a corresponding token, in wei.
     * @param token An array of addresses of ERC-20 compatible tokens.
     */
    setMinimumStakes(
      token: string[],
      minimumStake: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Uses `StakeManager` to decide if the Relay Manager can be considered staked or not. Returns if the stake's token, amount and delay satisfy all requirements, reverts otherwise.
     */
    verifyRelayManagerStaked(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Withdraws from an account's balance, sending it back to the caller. Relay Managers call this to retrieve their revenue, and `Paymasters` can also use it to reduce their funding. Emits a `Withdrawn` event.
     */
    withdraw(
      dest: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Withdraws from an account's balance, sending funds to multiple provided addresses. Relay Managers call this to retrieve their revenue, and `Paymasters` can also use it to reduce their funding. Emits a `Withdrawn` event for each destination.
     */
    withdrawMultiple(
      dest: string[],
      amount: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     */
    versionHub(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Uses `ArbSys` L2 block number specific to the Arbitrum Rollup.
     */
    getCreationBlock(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Uses original L1 block number.
     */
    getL1CreationBlock(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Includes the 'storage gas' specific to the Arbitrum Rollup.
     */
    aggregateGasleft(overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  /**
   * Add new worker addresses controlled by the sender who must be a staked Relay Manager address. Emits a `RelayWorkersAdded` event. This function can be called multiple times, emitting new events.
   */
  addRelayWorkers(
    newRelayWorkers: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  arbsys(overrides?: CallOverrides): Promise<string>;

  /**
   */
  balanceOf(target: string, overrides?: CallOverrides): Promise<BigNumber>;

  calculateCharge(
    gasUsed: BigNumberish,
    relayData: GsnTypes.RelayDataStruct,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * The fee is expressed as a  percentage of the actual charge. For example, a value '40' stands for a 40% fee, so the Relay Manager will only get 60% of the `charge`.
   * @param charge The amount of Ether in wei the Paymaster will be charged for this transaction.
   */
  calculateDevCharge(
    charge: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Deposits ether for a `Paymaster`, so that it can and pay for relayed transactions. :warning: **Warning** :warning: Unused balance can only be withdrawn by the holder itself, by calling `withdraw`. Emits a `Deposited` event.
   */
  depositFor(
    target: string,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Deprecate hub by reverting all incoming `relayCall()` calls starting from a given timestamp
   * @param _deprecationTime The timestamp in seconds after which the `RelayHub` stops serving transactions.
   */
  deprecateHub(
    _deprecationTime: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * @param relayManager
   */
  escheatAbandonedRelayBalance(
    relayManager: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   */
  getBatchGateway(overrides?: CallOverrides): Promise<string>;

  /**
   */
  getConfiguration(
    overrides?: CallOverrides
  ): Promise<IRelayHub.RelayHubConfigStructOutput>;

  /**
   */
  getDeprecationTime(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * @param token An address of an ERC-20 compatible tokens.
   */
  getMinimumStakePerToken(
    token: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   */
  getPenalizer(overrides?: CallOverrides): Promise<string>;

  /**
   */
  getRelayRegistrar(overrides?: CallOverrides): Promise<string>;

  /**
   */
  getStakeManager(overrides?: CallOverrides): Promise<string>;

  /**
   * @param manager An address of the Relay Manager.
   */
  getWorkerCount(
    manager: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * @param worker An address of the Relay Worker.
   */
  getWorkerManager(worker: string, overrides?: CallOverrides): Promise<string>;

  innerRelayCall(
    domainSeparatorName: string,
    relayRequest: GsnTypes.RelayRequestStruct,
    signature: BytesLike,
    approvalData: BytesLike,
    gasAndDataLimits: IPaymaster.GasAndDataLimitsStruct,
    totalInitialGas: BigNumberish,
    maxPossibleGas: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   */
  isDeprecated(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Uses `StakeManager` to check if the Relay Manager can be considered abandoned or not. Returns true if the stake's abandonment time is in the past including the escheatment delay, false otherwise.
   */
  isRelayEscheatable(
    relayManager: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * The `RelayRegistrar` callback to notify the `RelayHub` that this `relayManager` has updated registration.
   */
  onRelayServerRegistered(
    relayManager: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  /**
   * In case the Relay Worker has been found to be in violation of some rules by the `Penalizer` contract, the `Penalizer` will call this method to execute a penalization. The `RelayHub` will look up the Relay Manager of the given Relay Worker and will forward the call to the `StakeManager` contract. The `RelayHub` does not perform the actual penalization either.
   * @param beneficiary The address that called the `Penalizer` and will receive a reward for it.
   * @param relayWorker The address of the Relay Worker that committed a penalizable offense.
   */
  penalize(
    relayWorker: string,
    beneficiary: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  relayCall(
    domainSeparatorName: string,
    maxAcceptanceBudget: BigNumberish,
    relayRequest: GsnTypes.RelayRequestStruct,
    signature: BytesLike,
    approvalData: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.
   */
  renounceOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setConfiguration(
    _config: IRelayHub.RelayHubConfigStruct,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets or changes the minimum amount of a given `token` that needs to be staked so that the Relay Manager is considered to be 'staked' by this `RelayHub`. Zero value means this token is not allowed for staking.
   * @param minimumStake An array of minimal amounts necessary for a corresponding token, in wei.
   * @param token An array of addresses of ERC-20 compatible tokens.
   */
  setMinimumStakes(
    token: string[],
    minimumStake: BigNumberish[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
   */
  supportsInterface(
    interfaceId: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Uses `StakeManager` to decide if the Relay Manager can be considered staked or not. Returns if the stake's token, amount and delay satisfy all requirements, reverts otherwise.
   */
  verifyRelayManagerStaked(
    relayManager: string,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Withdraws from an account's balance, sending it back to the caller. Relay Managers call this to retrieve their revenue, and `Paymasters` can also use it to reduce their funding. Emits a `Withdrawn` event.
   */
  withdraw(
    dest: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Withdraws from an account's balance, sending funds to multiple provided addresses. Relay Managers call this to retrieve their revenue, and `Paymasters` can also use it to reduce their funding. Emits a `Withdrawn` event for each destination.
   */
  withdrawMultiple(
    dest: string[],
    amount: BigNumberish[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   */
  versionHub(overrides?: CallOverrides): Promise<string>;

  /**
   * Uses `ArbSys` L2 block number specific to the Arbitrum Rollup.
   */
  getCreationBlock(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Uses original L1 block number.
   */
  getL1CreationBlock(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Includes the 'storage gas' specific to the Arbitrum Rollup.
   */
  aggregateGasleft(overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    /**
     * Add new worker addresses controlled by the sender who must be a staked Relay Manager address. Emits a `RelayWorkersAdded` event. This function can be called multiple times, emitting new events.
     */
    addRelayWorkers(
      newRelayWorkers: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    arbsys(overrides?: CallOverrides): Promise<string>;

    /**
     */
    balanceOf(target: string, overrides?: CallOverrides): Promise<BigNumber>;

    calculateCharge(
      gasUsed: BigNumberish,
      relayData: GsnTypes.RelayDataStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The fee is expressed as a  percentage of the actual charge. For example, a value '40' stands for a 40% fee, so the Relay Manager will only get 60% of the `charge`.
     * @param charge The amount of Ether in wei the Paymaster will be charged for this transaction.
     */
    calculateDevCharge(
      charge: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Deposits ether for a `Paymaster`, so that it can and pay for relayed transactions. :warning: **Warning** :warning: Unused balance can only be withdrawn by the holder itself, by calling `withdraw`. Emits a `Deposited` event.
     */
    depositFor(target: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Deprecate hub by reverting all incoming `relayCall()` calls starting from a given timestamp
     * @param _deprecationTime The timestamp in seconds after which the `RelayHub` stops serving transactions.
     */
    deprecateHub(
      _deprecationTime: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * @param relayManager
     */
    escheatAbandonedRelayBalance(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     */
    getBatchGateway(overrides?: CallOverrides): Promise<string>;

    /**
     */
    getConfiguration(
      overrides?: CallOverrides
    ): Promise<IRelayHub.RelayHubConfigStructOutput>;

    /**
     */
    getDeprecationTime(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * @param token An address of an ERC-20 compatible tokens.
     */
    getMinimumStakePerToken(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     */
    getPenalizer(overrides?: CallOverrides): Promise<string>;

    /**
     */
    getRelayRegistrar(overrides?: CallOverrides): Promise<string>;

    /**
     */
    getStakeManager(overrides?: CallOverrides): Promise<string>;

    /**
     * @param manager An address of the Relay Manager.
     */
    getWorkerCount(
      manager: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * @param worker An address of the Relay Worker.
     */
    getWorkerManager(
      worker: string,
      overrides?: CallOverrides
    ): Promise<string>;

    innerRelayCall(
      domainSeparatorName: string,
      relayRequest: GsnTypes.RelayRequestStruct,
      signature: BytesLike,
      approvalData: BytesLike,
      gasAndDataLimits: IPaymaster.GasAndDataLimitsStruct,
      totalInitialGas: BigNumberish,
      maxPossibleGas: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number, string]>;

    /**
     */
    isDeprecated(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Uses `StakeManager` to check if the Relay Manager can be considered abandoned or not. Returns true if the stake's abandonment time is in the past including the escheatment delay, false otherwise.
     */
    isRelayEscheatable(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * The `RelayRegistrar` callback to notify the `RelayHub` that this `relayManager` has updated registration.
     */
    onRelayServerRegistered(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    /**
     * In case the Relay Worker has been found to be in violation of some rules by the `Penalizer` contract, the `Penalizer` will call this method to execute a penalization. The `RelayHub` will look up the Relay Manager of the given Relay Worker and will forward the call to the `StakeManager` contract. The `RelayHub` does not perform the actual penalization either.
     * @param beneficiary The address that called the `Penalizer` and will receive a reward for it.
     * @param relayWorker The address of the Relay Worker that committed a penalizable offense.
     */
    penalize(
      relayWorker: string,
      beneficiary: string,
      overrides?: CallOverrides
    ): Promise<void>;

    relayCall(
      domainSeparatorName: string,
      maxAcceptanceBudget: BigNumberish,
      relayRequest: GsnTypes.RelayRequestStruct,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber, number, string] & {
        paymasterAccepted: boolean;
        charge: BigNumber;
        status: number;
        returnValue: string;
      }
    >;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    setConfiguration(
      _config: IRelayHub.RelayHubConfigStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets or changes the minimum amount of a given `token` that needs to be staked so that the Relay Manager is considered to be 'staked' by this `RelayHub`. Zero value means this token is not allowed for staking.
     * @param minimumStake An array of minimal amounts necessary for a corresponding token, in wei.
     * @param token An array of addresses of ERC-20 compatible tokens.
     */
    setMinimumStakes(
      token: string[],
      minimumStake: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Uses `StakeManager` to decide if the Relay Manager can be considered staked or not. Returns if the stake's token, amount and delay satisfy all requirements, reverts otherwise.
     */
    verifyRelayManagerStaked(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Withdraws from an account's balance, sending it back to the caller. Relay Managers call this to retrieve their revenue, and `Paymasters` can also use it to reduce their funding. Emits a `Withdrawn` event.
     */
    withdraw(
      dest: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Withdraws from an account's balance, sending funds to multiple provided addresses. Relay Managers call this to retrieve their revenue, and `Paymasters` can also use it to reduce their funding. Emits a `Withdrawn` event for each destination.
     */
    withdrawMultiple(
      dest: string[],
      amount: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     */
    versionHub(overrides?: CallOverrides): Promise<string>;

    /**
     * Uses `ArbSys` L2 block number specific to the Arbitrum Rollup.
     */
    getCreationBlock(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Uses original L1 block number.
     */
    getL1CreationBlock(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Includes the 'storage gas' specific to the Arbitrum Rollup.
     */
    aggregateGasleft(overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    "AbandonedRelayManagerBalanceEscheated(address,uint256)"(
      relayManager?: string | null,
      balance?: null
    ): AbandonedRelayManagerBalanceEscheatedEventFilter;
    AbandonedRelayManagerBalanceEscheated(
      relayManager?: string | null,
      balance?: null
    ): AbandonedRelayManagerBalanceEscheatedEventFilter;

    "Deposited(address,address,uint256)"(
      paymaster?: string | null,
      from?: string | null,
      amount?: null
    ): DepositedEventFilter;
    Deposited(
      paymaster?: string | null,
      from?: string | null,
      amount?: null
    ): DepositedEventFilter;

    "HubDeprecated(uint256)"(deprecationTime?: null): HubDeprecatedEventFilter;
    HubDeprecated(deprecationTime?: null): HubDeprecatedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "RelayHubConfigured((uint256,uint256,uint256,uint256,uint256,address,uint8,uint80,uint16))"(
      config?: null
    ): RelayHubConfiguredEventFilter;
    RelayHubConfigured(config?: null): RelayHubConfiguredEventFilter;

    "RelayWorkersAdded(address,address[],uint256)"(
      relayManager?: string | null,
      newRelayWorkers?: null,
      workersCount?: null
    ): RelayWorkersAddedEventFilter;
    RelayWorkersAdded(
      relayManager?: string | null,
      newRelayWorkers?: null,
      workersCount?: null
    ): RelayWorkersAddedEventFilter;

    "StakingTokenDataChanged(address,uint256)"(
      token?: null,
      minimumStake?: null
    ): StakingTokenDataChangedEventFilter;
    StakingTokenDataChanged(
      token?: null,
      minimumStake?: null
    ): StakingTokenDataChangedEventFilter;

    "TransactionRejectedByPaymaster(address,address,bytes32,address,address,address,bytes4,uint256,bytes)"(
      relayManager?: string | null,
      paymaster?: string | null,
      relayRequestID?: BytesLike | null,
      from?: null,
      to?: null,
      relayWorker?: null,
      selector?: null,
      innerGasUsed?: null,
      reason?: null
    ): TransactionRejectedByPaymasterEventFilter;
    TransactionRejectedByPaymaster(
      relayManager?: string | null,
      paymaster?: string | null,
      relayRequestID?: BytesLike | null,
      from?: null,
      to?: null,
      relayWorker?: null,
      selector?: null,
      innerGasUsed?: null,
      reason?: null
    ): TransactionRejectedByPaymasterEventFilter;

    "TransactionRelayed(address,address,bytes32,address,address,address,bytes4,uint8,uint256)"(
      relayManager?: string | null,
      relayWorker?: string | null,
      relayRequestID?: BytesLike | null,
      from?: null,
      to?: null,
      paymaster?: null,
      selector?: null,
      status?: null,
      charge?: null
    ): TransactionRelayedEventFilter;
    TransactionRelayed(
      relayManager?: string | null,
      relayWorker?: string | null,
      relayRequestID?: BytesLike | null,
      from?: null,
      to?: null,
      paymaster?: null,
      selector?: null,
      status?: null,
      charge?: null
    ): TransactionRelayedEventFilter;

    "TransactionResult(uint8,bytes)"(
      status?: null,
      returnValue?: null
    ): TransactionResultEventFilter;
    TransactionResult(
      status?: null,
      returnValue?: null
    ): TransactionResultEventFilter;

    "Withdrawn(address,address,uint256)"(
      account?: string | null,
      dest?: string | null,
      amount?: null
    ): WithdrawnEventFilter;
    Withdrawn(
      account?: string | null,
      dest?: string | null,
      amount?: null
    ): WithdrawnEventFilter;
  };

  estimateGas: {
    /**
     * Add new worker addresses controlled by the sender who must be a staked Relay Manager address. Emits a `RelayWorkersAdded` event. This function can be called multiple times, emitting new events.
     */
    addRelayWorkers(
      newRelayWorkers: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    arbsys(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     */
    balanceOf(target: string, overrides?: CallOverrides): Promise<BigNumber>;

    calculateCharge(
      gasUsed: BigNumberish,
      relayData: GsnTypes.RelayDataStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The fee is expressed as a  percentage of the actual charge. For example, a value '40' stands for a 40% fee, so the Relay Manager will only get 60% of the `charge`.
     * @param charge The amount of Ether in wei the Paymaster will be charged for this transaction.
     */
    calculateDevCharge(
      charge: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Deposits ether for a `Paymaster`, so that it can and pay for relayed transactions. :warning: **Warning** :warning: Unused balance can only be withdrawn by the holder itself, by calling `withdraw`. Emits a `Deposited` event.
     */
    depositFor(
      target: string,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Deprecate hub by reverting all incoming `relayCall()` calls starting from a given timestamp
     * @param _deprecationTime The timestamp in seconds after which the `RelayHub` stops serving transactions.
     */
    deprecateHub(
      _deprecationTime: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * @param relayManager
     */
    escheatAbandonedRelayBalance(
      relayManager: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     */
    getBatchGateway(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     */
    getConfiguration(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     */
    getDeprecationTime(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * @param token An address of an ERC-20 compatible tokens.
     */
    getMinimumStakePerToken(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     */
    getPenalizer(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     */
    getRelayRegistrar(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     */
    getStakeManager(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * @param manager An address of the Relay Manager.
     */
    getWorkerCount(
      manager: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * @param worker An address of the Relay Worker.
     */
    getWorkerManager(
      worker: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    innerRelayCall(
      domainSeparatorName: string,
      relayRequest: GsnTypes.RelayRequestStruct,
      signature: BytesLike,
      approvalData: BytesLike,
      gasAndDataLimits: IPaymaster.GasAndDataLimitsStruct,
      totalInitialGas: BigNumberish,
      maxPossibleGas: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     */
    isDeprecated(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Uses `StakeManager` to check if the Relay Manager can be considered abandoned or not. Returns true if the stake's abandonment time is in the past including the escheatment delay, false otherwise.
     */
    isRelayEscheatable(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The `RelayRegistrar` callback to notify the `RelayHub` that this `relayManager` has updated registration.
     */
    onRelayServerRegistered(
      relayManager: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * In case the Relay Worker has been found to be in violation of some rules by the `Penalizer` contract, the `Penalizer` will call this method to execute a penalization. The `RelayHub` will look up the Relay Manager of the given Relay Worker and will forward the call to the `StakeManager` contract. The `RelayHub` does not perform the actual penalization either.
     * @param beneficiary The address that called the `Penalizer` and will receive a reward for it.
     * @param relayWorker The address of the Relay Worker that committed a penalizable offense.
     */
    penalize(
      relayWorker: string,
      beneficiary: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    relayCall(
      domainSeparatorName: string,
      maxAcceptanceBudget: BigNumberish,
      relayRequest: GsnTypes.RelayRequestStruct,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setConfiguration(
      _config: IRelayHub.RelayHubConfigStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets or changes the minimum amount of a given `token` that needs to be staked so that the Relay Manager is considered to be 'staked' by this `RelayHub`. Zero value means this token is not allowed for staking.
     * @param minimumStake An array of minimal amounts necessary for a corresponding token, in wei.
     * @param token An array of addresses of ERC-20 compatible tokens.
     */
    setMinimumStakes(
      token: string[],
      minimumStake: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Uses `StakeManager` to decide if the Relay Manager can be considered staked or not. Returns if the stake's token, amount and delay satisfy all requirements, reverts otherwise.
     */
    verifyRelayManagerStaked(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Withdraws from an account's balance, sending it back to the caller. Relay Managers call this to retrieve their revenue, and `Paymasters` can also use it to reduce their funding. Emits a `Withdrawn` event.
     */
    withdraw(
      dest: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Withdraws from an account's balance, sending funds to multiple provided addresses. Relay Managers call this to retrieve their revenue, and `Paymasters` can also use it to reduce their funding. Emits a `Withdrawn` event for each destination.
     */
    withdrawMultiple(
      dest: string[],
      amount: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     */
    versionHub(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Uses `ArbSys` L2 block number specific to the Arbitrum Rollup.
     */
    getCreationBlock(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Uses original L1 block number.
     */
    getL1CreationBlock(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Includes the 'storage gas' specific to the Arbitrum Rollup.
     */
    aggregateGasleft(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Add new worker addresses controlled by the sender who must be a staked Relay Manager address. Emits a `RelayWorkersAdded` event. This function can be called multiple times, emitting new events.
     */
    addRelayWorkers(
      newRelayWorkers: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    arbsys(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     */
    balanceOf(
      target: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    calculateCharge(
      gasUsed: BigNumberish,
      relayData: GsnTypes.RelayDataStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The fee is expressed as a  percentage of the actual charge. For example, a value '40' stands for a 40% fee, so the Relay Manager will only get 60% of the `charge`.
     * @param charge The amount of Ether in wei the Paymaster will be charged for this transaction.
     */
    calculateDevCharge(
      charge: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Deposits ether for a `Paymaster`, so that it can and pay for relayed transactions. :warning: **Warning** :warning: Unused balance can only be withdrawn by the holder itself, by calling `withdraw`. Emits a `Deposited` event.
     */
    depositFor(
      target: string,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Deprecate hub by reverting all incoming `relayCall()` calls starting from a given timestamp
     * @param _deprecationTime The timestamp in seconds after which the `RelayHub` stops serving transactions.
     */
    deprecateHub(
      _deprecationTime: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * @param relayManager
     */
    escheatAbandonedRelayBalance(
      relayManager: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     */
    getBatchGateway(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     */
    getConfiguration(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     */
    getDeprecationTime(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * @param token An address of an ERC-20 compatible tokens.
     */
    getMinimumStakePerToken(
      token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     */
    getPenalizer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     */
    getRelayRegistrar(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     */
    getStakeManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * @param manager An address of the Relay Manager.
     */
    getWorkerCount(
      manager: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * @param worker An address of the Relay Worker.
     */
    getWorkerManager(
      worker: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    innerRelayCall(
      domainSeparatorName: string,
      relayRequest: GsnTypes.RelayRequestStruct,
      signature: BytesLike,
      approvalData: BytesLike,
      gasAndDataLimits: IPaymaster.GasAndDataLimitsStruct,
      totalInitialGas: BigNumberish,
      maxPossibleGas: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     */
    isDeprecated(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Uses `StakeManager` to check if the Relay Manager can be considered abandoned or not. Returns true if the stake's abandonment time is in the past including the escheatment delay, false otherwise.
     */
    isRelayEscheatable(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The `RelayRegistrar` callback to notify the `RelayHub` that this `relayManager` has updated registration.
     */
    onRelayServerRegistered(
      relayManager: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * In case the Relay Worker has been found to be in violation of some rules by the `Penalizer` contract, the `Penalizer` will call this method to execute a penalization. The `RelayHub` will look up the Relay Manager of the given Relay Worker and will forward the call to the `StakeManager` contract. The `RelayHub` does not perform the actual penalization either.
     * @param beneficiary The address that called the `Penalizer` and will receive a reward for it.
     * @param relayWorker The address of the Relay Worker that committed a penalizable offense.
     */
    penalize(
      relayWorker: string,
      beneficiary: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    relayCall(
      domainSeparatorName: string,
      maxAcceptanceBudget: BigNumberish,
      relayRequest: GsnTypes.RelayRequestStruct,
      signature: BytesLike,
      approvalData: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setConfiguration(
      _config: IRelayHub.RelayHubConfigStruct,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets or changes the minimum amount of a given `token` that needs to be staked so that the Relay Manager is considered to be 'staked' by this `RelayHub`. Zero value means this token is not allowed for staking.
     * @param minimumStake An array of minimal amounts necessary for a corresponding token, in wei.
     * @param token An array of addresses of ERC-20 compatible tokens.
     */
    setMinimumStakes(
      token: string[],
      minimumStake: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.
     */
    supportsInterface(
      interfaceId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Uses `StakeManager` to decide if the Relay Manager can be considered staked or not. Returns if the stake's token, amount and delay satisfy all requirements, reverts otherwise.
     */
    verifyRelayManagerStaked(
      relayManager: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraws from an account's balance, sending it back to the caller. Relay Managers call this to retrieve their revenue, and `Paymasters` can also use it to reduce their funding. Emits a `Withdrawn` event.
     */
    withdraw(
      dest: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Withdraws from an account's balance, sending funds to multiple provided addresses. Relay Managers call this to retrieve their revenue, and `Paymasters` can also use it to reduce their funding. Emits a `Withdrawn` event for each destination.
     */
    withdrawMultiple(
      dest: string[],
      amount: BigNumberish[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     */
    versionHub(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Uses `ArbSys` L2 block number specific to the Arbitrum Rollup.
     */
    getCreationBlock(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Uses original L1 block number.
     */
    getL1CreationBlock(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Includes the 'storage gas' specific to the Arbitrum Rollup.
     */
    aggregateGasleft(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
