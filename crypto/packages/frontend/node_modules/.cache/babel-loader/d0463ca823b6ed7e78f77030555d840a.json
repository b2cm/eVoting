{"ast":null,"code":"const EC = require(\"elliptic\").ec;\nconst SHA256 = require(\"js-sha256\").sha256;\nconst BigInteger = require(\"bn.js\");\nconst Hmac = require(\"js-sha256\").sha256.hmac;\nconst crypto = require('crypto');\nconst BigInt = val => {\n  return window.BigInt(val);\n};\n_c = BigInt;\nclass VRF {\n  constructor() {\n    this.COFACTOR = 1;\n    const curve = \"secp256k1\";\n    // secp256k1 curve\n    this.ec = new EC(curve);\n    this.BASE = this.ec.curve.g;\n    this.PRIME = this.ec.curve.p;\n    this.ORDER = this.ec.curve.n;\n    this.SUITE_STRING = [0x10];\n  }\n\n  // Section 5.1. EC-VRF Priving\n  /**\n   * Compute the VRF proof\n   * @param sk private key, an number (32 bytes)\n   * @param alpha_string VRF input, an octet string\n   * @return pi - VRF proof octet string of length m+3n = ptLen+n+qLen = 81 bytes\n   */\n  prove(sk, alpha_string) {\n    // 1. Use sk to derive the VRF secret scalar x and the public key\n    const secret_scalar_x = new BigInteger(sk, \"hex\");\n    const pk = this.BASE.mul(secret_scalar_x);\n\n    // 2. H = ECVRF_hash_to_curve(pk, alpha_string)\n    const h = this.hash_to_curve_try_and_increment(this.SUITE_STRING, pk, alpha_string);\n    if (h == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 3. h_string = point_to_string(H)\n    const h_string = this.point_to_string(h);\n    if (h_string == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 4. Gamma = x*H\n    const gamma = h.mul(secret_scalar_x);\n\n    // 5. Choose A random number nonce k from [0, q-1]\n    const k = this.nonce_generation_rfc6979(sk, h_string);\n\n    // 6. c = ECVRF_hash_points(H, Gamma, g^k, h^k)\n    const k_b = this.BASE.mul(new BigInteger(k));\n    const k_h = h.mul(new BigInteger(k));\n    const c = this.hash_points(h, gamma, k_b, k_h);\n\n    // 7. s = (k + c*x) mod q (where * denotes number multiplication)\n    const s = (k + c * BigInt(secret_scalar_x)) % BigInt(this.ORDER);\n\n    // 8. pi_string = point_to_string(Gamma) || int_to_string(c, n) || int_to_string(s, qLen)\n    const pi_string = this.point_to_string(gamma) + this.int_to_string(c, 16) + this.int_to_string(s, 32);\n\n    // 9. Output pi_string\n    return pi_string;\n  }\n\n  // Section 5.2. ECVRF Proof To Hash\n  /**\n     * ECVRF_proof_to_hash(pi_string)\n     * @param pi_string VRF proof, octet string of length m+3n (80) bytes\n     * @return (\"VALID\", beta_string) where beta_string is the VRF hash output, octet string\n            of length hLen (64) bytes, or (\"INVALID\", []) upon failure\n     */\n  proof_to_hash(pi_string) {\n    // 1. D = ECVRF_decode_proof(pi_string)\n    // 2. If D is 'INVALID', output 'INVALID' and stop\n    const d = this.decode_proof(pi_string);\n    if (d == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 3. (Gamma, c, s) = D\n    let gamma = d[0];\n    gamma = this.string_to_bytes(this.point_to_string(gamma));\n\n    // 4. three_string = 0x03 = int_to_string(3, 1), A single octet with value 3\n    const three_string = [0x03];\n\n    // 5. beta_string = Hash(suite_string || three_string || point_to_string(cofactor * Gamma))\n    const beta_string = SHA256.create().update(this.SUITE_STRING.concat(three_string, gamma)).hex();\n\n    // 6. Output beta_string\n    return beta_string;\n  }\n\n  // 5.3. ECVRF Verifying\n  /**\n     * ECVRF_verify(Y, pi_string, alpha_string)\n     * @param pk public key, an EC point\n     * @param pi_string  VRF proof, octet string of length ptLen+n+qLen\n     * @param alpha_string VRF input, octet string\n     * @return (\"VALID\", beta_string), where beta_string is the VRF hash output, octet string\n            of length hLen (64) bytes; or (\"INVALID\", []) upon failure\n     */\n  verify(pk, pi_string, alpha_string) {\n    // 1. D = ECVRF_decode_proof(pi_string)\n    // 2. If D is \"INVALID\", output \"INVALID\" and stop\n    pk = this.string_to_point(pk);\n    const d = this.decode_proof(pi_string);\n    if (d == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 3. (Gamma, c, s) = D\n    const gamma = d[0];\n    const c = d[1];\n    const s = d[2];\n\n    // 4. H = ECVRF_hash_to_curve(suite_string, pk, alpha_string)\n    const h = this.hash_to_curve_try_and_increment(this.SUITE_STRING, pk, alpha_string);\n    if (h == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 5. U = s*B - c*pk\n    const s_b = this.BASE.mul(new BigInteger(s));\n    const c_y = pk.mul(new BigInteger(c));\n    const u = s_b.add(c_y.neg());\n\n    // 6. V = s*H - c*Gamma\n    const s_h = h.mul(new BigInteger(s));\n    const c_g = gamma.mul(new BigInteger(c));\n    const v = s_h.add(c_g.neg());\n\n    // 7. c’ = ECVRF_hash_points(H, Gamma, U, V)\n    const cp = this.hash_points(h, gamma, u, v);\n\n    // 8. If c and c’ are equal, output (\"VALID\", ECVRF_proof_to_hash(pi_string)); else output \"INVALID\"\n    if (c == cp) {\n      return {\n        status: \"VALID\",\n        beta_string: this.proof_to_hash(pi_string)\n      };\n    } else {\n      return {\n        status: \"INVALID\",\n        beta_string: \"\"\n      };\n    }\n  }\n\n  ///// ECVRF Auxiliary functions\n\n  // Section 5.4.1.1.\n  /**\n     * The ECVRF_hash_to_curve algorithm takes in the VRF input alpha and\n     converts it to H, an EC point in G\n     * @param {*} suite_string A single octet specifying ECVRF ciphersuite\n     * @param {*} pk public key, an EC point\n     * @param {*} alpha_string value to be hashed, an octet string\n     * @return  H - hashed value, A finite EC point in G, or INVALID upon failure\n     */\n  hash_to_curve_try_and_increment(suite_string, pk, alpha_string) {\n    // 1. ctr = 0\n    let ctr = 0x00;\n\n    // 2. PK_string = point_to_string(Y)\n    const pk_string = this.string_to_bytes(pk.encodeCompressed(\"hex\"));\n    alpha_string = this.string_to_bytes(alpha_string);\n\n    // 3. one_string = 0x01 = int_to_string(1, 1), A single octet with value 1\n    const one_string = 0x01;\n\n    // 4. H = 'INVALID'\n    let H = \"INVALID\";\n\n    // 5. While H is \"INVALID\" or H is EC point at infinity\n    while (H == \"INVALID\" || H.isInfinity()) {\n      // A. ctr_string = int_to_string(ctr, 1)\n      // B. hash_string = Hash(suite_string || one_string || PK_string ||alpha_string || ctr_string)\n      const hash_string = SHA256.create().update([suite_string, one_string, ...pk_string, ...alpha_string, ctr]).digest();\n\n      // C. H = arbitrary_string_to_point(hash_string)\n      H = this.string_to_point([0x02, ...hash_string]);\n\n      // D.  If H is not \"INVALID\" and cofactor > 1, set H = cofactor * H\n      // We can omit these step because cofactor = 1\n\n      // E. ctr = ctr + 1\n      ctr = ctr + 0x01;\n    }\n\n    // 6. Output H\n    return H;\n  }\n\n  // Section 5.4.2.1. ECVRF Nonce Generation From RFC 6979\n  /**\n   * Random nonce generation\n   * @param sk an ECVRF secret key as bytes\n   * @param h_string an octet string\n   * @return k an number between 0 and q-1\n   */\n  nonce_generation_rfc6979(sk, h_string) {\n    // a. Process m through the hash function H, yielding:\n    h_string = this.string_to_bytes(h_string);\n    let h1 = SHA256.create().update(h_string).digest();\n    h1 = this.bits2octets(h1, this.ORDER);\n    sk = this.int2octets(BigInt(\"0x\" + sk), this.ORDER.bitLength());\n\n    // b. set V = 0x01 0x01 0x01 ... 0x01 such that the length of V, in bits, is equal to 8*ceil(hlen/8).\n    let v = Array(32).fill(0x01);\n\n    // c. Set: K = 0x00 0x00 0x00 ... 0x00 such that the length of K, in bits, is equal to 8*ceil(hlen/8).\n    let k = Array(32).fill(0x00);\n\n    // d.  Set: K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1)) where '||' denotes concatenation.\n    //k = Hmac.create(k).update(v.concat(0x00, sk, h1)).digest()\n    k = Hmac.create(k).update(v).update([0x00]).update(sk).update(h1).digest();\n\n    // e. Set: V = HMAC_K(V)\n    v = Hmac.create(k).update(v).digest();\n\n    // f. Set:  K = HMAC_K(V || 0x01 || int2octets(x) || bits2octets(h1))\n    //k = Hmac.create(k).update(v.concat(0x01, sk, h1)).digest()\n    k = Hmac.create(k).update(v).update([0x01]).update(sk).update(h1).digest();\n\n    // g. Set: V = HMAC_K(V)\n    v = Hmac.create(k).update(v).digest();\n\n    // h. Apply the following algorithm until a proper value is found for k:\n    // 1. Set T to the empty sequence.  The length of T (in bits) is denoted tlen; thus, at that point, tlen = 0.\n\n    // 2.\n    while (true) {\n      v = Hmac.create(k).update(v).digest();\n      const k_int = this.bits2int(v, this.ORDER.bitLength());\n      if (k_int < BigInt(this.ORDER) - 1n) {\n        return k_int;\n      }\n      k = SHA256.hmac.create(k).update(v).update([0x00]).digest();\n      v = SHA256.hmac.create(k).update(v).digest();\n    }\n  }\n\n  // section 5.4.3. ECVRF Hash Points\n  /**\n   * ECVRF_hash_points(P1, P2, ..., PM)\n   * @param p1 an EC points in G\n   * @param p2 an EC points in G\n   * @param p3 an EC points in G\n   * @param p4 an EC points in G\n   * @retrun c hash value, number between 0 and 2^(8n)-1\n   */\n  hash_points(p1, p2, p3, p4) {\n    // 1. two_string = 0x02 = int_to_string(2, 1), A single octet with value 2\n    const two_string = [0x02];\n\n    // 2. Initialize str = suite_string || two_string\n    let string = this.SUITE_STRING.concat(two_string);\n\n    // 3.for PJ in [P1, P2, ... PM]:\n    // str = str || point_to_string(PJ)\n    p1 = this.string_to_bytes(this.point_to_string(p1));\n    p2 = this.string_to_bytes(this.point_to_string(p2));\n    p3 = this.string_to_bytes(this.point_to_string(p3));\n    p4 = this.string_to_bytes(this.point_to_string(p4));\n    string = string.concat(p1, p2, p3, p4);\n\n    // 4. c_string = Hash(str)\n    const c_string = this.hash(string);\n\n    // 5. truncated_c_string = c_string[0]...c_string[n-1]\n    const truncated_c_string = c_string.slice(0, 16);\n\n    // 6. c = string_to_int(truncated_c_string)\n    const c = this.string_to_int(truncated_c_string);\n\n    // 7. Output c\n    return c;\n  }\n\n  // Section 5.4.4. ECVRF Decode Proof\n  /**\n     * ECVRF_decode_proof(pi_string)\n     * @param pi_string VRF proof, octet string (ptLen+n+qLen octets)\n     * @return \"INVALID\", or \n            Gamma - EC point,\n            c - number between 0 and 2^(8n)-1,\n            s - number between 0 and 2^(8qLen)-1\n     */\n  decode_proof(pi_string) {\n    // ptLen+n+qLen octets = 33+16+32 = 81\n    pi_string = this.string_to_bytes(pi_string);\n    if (pi_string.length != 81) {\n      return \"INVALID\";\n    }\n\n    // 1. let gamma_string = pi_string[0]...p_string[ptLen-1]\n    const gamma_string = pi_string.slice(0, 33);\n\n    // let c_string = pi_string[ptLen]...pi_string[ptLen+n-1]\n    const c_string = pi_string.slice(33, 49);\n\n    // 3. let s_string =pi_string[ptLen+n]...pi_string[ptLen+n+qLen-1]\n    const s_string = pi_string.slice(49);\n\n    // 4. Gamma = string_to_point(gamma_string)\n    // 5. if Gamma = \"INVALID\" output \"INVALID\" and stop.\n    const gamma = this.string_to_point(gamma_string);\n    if (gamma == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 6. c = string_to_int(c_string)\n    const c = this.string_to_int(c_string);\n\n    // 7. s = string_to_int(s_string)\n    const s = this.string_to_int(s_string);\n\n    // 8. Output Gamma, c, and s\n    return [gamma, c, s];\n  }\n  computeFastVerifyParams(pk, pi_string, alpha_string) {\n    // 1. D = ECVRF_decode_proof(pi_string)\n    // 2. If D is \"INVALID\", output \"INVALID\" and stop\n    pk = this.string_to_point(pk);\n    const d = this.decode_proof(pi_string);\n    if (d == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 3. (Gamma, c, s) = D\n    const gamma = d[0];\n    const c = d[1];\n    const s = d[2];\n\n    // 4. H = ECVRF_hash_to_curve(suite_string, pk, alpha_string)\n    const h = this.hash_to_curve_try_and_increment(this.SUITE_STRING, pk, alpha_string);\n    if (h == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 5. U = s*B - c*pk\n    const s_b = this.BASE.mul(new BigInteger(s));\n    const c_y = pk.mul(new BigInteger(c));\n    const u = s_b.add(c_y.neg());\n\n    // 6. V = s*H - c*Gamma\n    const s_h = h.mul(new BigInteger(s));\n    const c_g = gamma.mul(new BigInteger(c));\n    const v = s_h.add(c_g.neg());\n    const uX = u.getX().toString(16);\n    const uY = u.getY().toString(16);\n    const vX = v.getX().toString(16);\n    const vY = v.getY().toString(16);\n    const shX = s_h.getX();\n    const shY = s_h.getY();\n    const gammaX = c_g.getX();\n    const gammaY = c_g.getY();\n    const uPoint = [uX, uY];\n    const vPoint = [vX, vY];\n    const vComponents = [shX, shY, gammaX, gammaY];\n    const hX = h.getX().toString(16);\n    const hY = h.getY().toString(16);\n    const hPoint = [hX, hY];\n    return {\n      uPoint,\n      vPoint\n    };\n  }\n\n  /**\n   * Hash function\n   * @param message - An array of number\n   * @returns Hash value as an Array of number\n   */\n  hash(message) {\n    return SHA256.create().update(message).digest();\n  }\n\n  /**\n   * conversion of EC point to an ptLen-octet string  as specified in Section 5.5.\n   * @param point An EC point\n   * @returns An octet string reprasenting the EC point\n   */\n  point_to_string(point) {\n    return point.encodeCompressed(\"hex\");\n  }\n\n  /**\n    * conversion of an ptLen-octet string to EC point\n    as specified in Section 5.5. \n    * @param a_string an 32-bytes string\n    * @returns An EC point\n    */\n  string_to_point(a_string) {\n    try {\n      return this.ec.curve.decodePoint(a_string, \"hex\");\n    } catch (error) {\n      return \"INVALID\";\n    }\n  }\n\n  /**\n   * string_to_int(a_string) - conversion of an octet string to A nonnegative number as specified in Section 5.5.\n   * @param a_string An array of number representing the octect string\n   * @returns A BigInt in big endian\n   */\n  string_to_int(a_string) {\n    if (!(a_string instanceof Array)) a_string = this.string_to_bytes(a_string);\n    return BigInt(\"0x\" + a_string.map(byte => byte.toString(16).padStart(2, \"0\")).join(\"\"));\n  }\n\n  /**\n   * int_to_string(A, len) - conversion of nonnegative number A to an octet string of length len as specified in Section 5.5.\n   * @param number A BigInteger\n   * @param len length of the string\n   * @returns A octet string in big endian\n   */\n  int_to_string(number, len) {\n    number = number.toString(16);\n    const numLen = number.length;\n    if (numLen % 2 != 0) number = \"0\" + number;\n    const bytes = this.string_to_bytes(number);\n    return bytes.slice(0, len).map(byte => byte.toString(16).padStart(2, \"0\")).join(\"\");\n  }\n\n  /**\n   * Convert string to bytes\n   * @param octet_string  A string\n   * @returns An array of number\n   */\n  string_to_bytes(octet_string) {\n    if (!(octet_string instanceof String)) octet_string = octet_string.toString(16);\n    const A = [];\n    for (let i = 0; i < octet_string.length; i = i + 2) {\n      A.push(parseInt(octet_string.substr(i, 2), 16));\n    }\n    return A;\n  }\n  bits2octets(bits, q) {\n    const z1 = this.bits2int(bits, q.bitLength());\n    const z2 = z1 % BigInt(q);\n    return this.int2octets(z2, q.bitLength());\n  }\n  bits2int(bits, qLen) {\n    const bLen = bits.length * 8;\n    let integer = BigInt(\"0x\" + bits.map(byte => byte.toString(16).padStart(2, \"0\")).join(\"\"));\n    if (qLen < bLen) {\n      integer = integer >> BigInt(bLen - qLen);\n    }\n    return integer;\n  }\n  int2octets(int, qLen) {\n    int = int.toString(16);\n    if (int.length % 2 != 0) int = \"0\" + int;\n    let octets = this.string_to_bytes(int);\n    const rLen = 8 * (qLen / 8);\n    const bLen = octets.length * 8;\n    if (bLen < rLen) {\n      // left pad with rlen - blen bits\n      const padNum = Math.ceil((rLen - bLen) / 8);\n      //console.log('padnum', padNum)\n      const leftPaddedBits = Array(padNum).fill(0x00, 0, padNum);\n      octets = leftPaddedBits.concat(octets);\n    }\n    if (bLen > rLen) {\n      // truncate to rlen bits\n      octets = octets.slice(0, Math.ceil(qLen / 8));\n    }\n    return octets;\n  }\n  hex_to_ascii(str1) {\n    var hex = str1.toString();\n    var str = \"\";\n    for (var n = 0; n < hex.length; n += 2) {\n      str += String.fromCharCode(parseInt(hex.substr(n, 2), 16));\n    }\n    return str;\n  }\n  ascii_to_hex(str) {\n    var arr1 = [];\n    for (var n = 0, l = str.length; n < l; n++) {\n      var hex = Number(str.charCodeAt(n)).toString(16);\n      arr1.push(hex);\n    }\n    return arr1.join(\"\");\n  }\n}\nfunction generateRandomHexString(length) {\n  const bytes = new Uint8Array(length / 2);\n  const _crypto = typeof window === \"undefined\" ? require(\"crypto\").webcrypto : window.crypto;\n  _crypto.getRandomValues(bytes);\n  return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');\n}\n\n//function generateRandomString(length) {\n//  let result = '';\n//  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n//  for (let i = 0; i < length; i++) {\n//    result += characters.charAt(Math.floor(Math.random() * characters.length));\n//  }\n//  return result;\n// }\n\n// Formula to generate random number \nconst VrfGenerator = () => {\n  const sk = crypto.randomBytes(32).toString('hex');\n  //const sk = \"c9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721\"\n  const vrf = new VRF();\n  const piString = vrf.prove(sk, generateRandomHexString(8));\n  console.log(\"pi==>\", piString);\n  const BetaString = vrf.proof_to_hash(piString);\n  console.log(\"Beta==>\", BetaString);\n  const hash = SHA256(BetaString);\n  const hashLength = hash.length;\n  const divisor = Math.pow(2, hashLength);\n  const randomNumber = parseInt(hash, 16) / divisor;\n  return randomNumber.toString();\n};\n\n//console.log(VrfGenerator());\n\n//module.exports = VrfGenerator;\n_c2 = VrfGenerator;\nexport default VrfGenerator;\nvar _c, _c2;\n$RefreshReg$(_c, \"BigInt\");\n$RefreshReg$(_c2, \"VrfGenerator\");","map":{"version":3,"names":["EC","require","ec","SHA256","sha256","BigInteger","Hmac","hmac","crypto","BigInt","val","window","_c","VRF","constructor","COFACTOR","curve","BASE","g","PRIME","p","ORDER","n","SUITE_STRING","prove","sk","alpha_string","secret_scalar_x","pk","mul","h","hash_to_curve_try_and_increment","h_string","point_to_string","gamma","k","nonce_generation_rfc6979","k_b","k_h","c","hash_points","s","pi_string","int_to_string","proof_to_hash","d","decode_proof","string_to_bytes","three_string","beta_string","create","update","concat","hex","verify","string_to_point","s_b","c_y","u","add","neg","s_h","c_g","v","cp","status","suite_string","ctr","pk_string","encodeCompressed","one_string","H","isInfinity","hash_string","digest","h1","bits2octets","int2octets","bitLength","Array","fill","k_int","bits2int","p1","p2","p3","p4","two_string","string","c_string","hash","truncated_c_string","slice","string_to_int","length","gamma_string","s_string","computeFastVerifyParams","uX","getX","toString","uY","getY","vX","vY","shX","shY","gammaX","gammaY","uPoint","vPoint","vComponents","hX","hY","hPoint","message","point","a_string","decodePoint","error","map","byte","padStart","join","number","len","numLen","bytes","octet_string","String","A","i","push","parseInt","substr","bits","q","z1","z2","qLen","bLen","integer","int","octets","rLen","padNum","Math","ceil","leftPaddedBits","hex_to_ascii","str1","str","fromCharCode","ascii_to_hex","arr1","l","Number","charCodeAt","generateRandomHexString","Uint8Array","_crypto","webcrypto","getRandomValues","from","VrfGenerator","randomBytes","vrf","piString","console","log","BetaString","hashLength","divisor","pow","randomNumber","_c2","$RefreshReg$"],"sources":["/Users/kemlohalex/Documents/evoting/crypto/packages/frontend/src/Vrf/vrf.jsx"],"sourcesContent":["const EC = require(\"elliptic\").ec;\nconst SHA256 = require(\"js-sha256\").sha256;\nconst BigInteger = require(\"bn.js\");\nconst Hmac = require(\"js-sha256\").sha256.hmac;\nconst crypto = require('crypto');\n\n\nconst BigInt = (val) => {\n    return window.BigInt(val)\n  }\n\n\nclass VRF {\n  constructor() {\n    this.COFACTOR = 1;\n    const curve = \"secp256k1\";\n    // secp256k1 curve\n    this.ec = new EC(curve);\n    this.BASE = this.ec.curve.g;\n    this.PRIME = this.ec.curve.p;\n    this.ORDER = this.ec.curve.n;\n    this.SUITE_STRING = [0x10];\n  }\n\n  // Section 5.1. EC-VRF Priving\n  /**\n   * Compute the VRF proof\n   * @param sk private key, an number (32 bytes)\n   * @param alpha_string VRF input, an octet string\n   * @return pi - VRF proof octet string of length m+3n = ptLen+n+qLen = 81 bytes\n   */\n  prove(sk, alpha_string) {\n    // 1. Use sk to derive the VRF secret scalar x and the public key\n    const secret_scalar_x = new BigInteger(sk, \"hex\");\n    const pk = this.BASE.mul(secret_scalar_x);\n\n    // 2. H = ECVRF_hash_to_curve(pk, alpha_string)\n    const h = this.hash_to_curve_try_and_increment(\n      this.SUITE_STRING,\n      pk,\n      alpha_string\n    );\n    if (h == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 3. h_string = point_to_string(H)\n    const h_string = this.point_to_string(h);\n    if (h_string == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 4. Gamma = x*H\n    const gamma = h.mul(secret_scalar_x);\n\n    // 5. Choose A random number nonce k from [0, q-1]\n    const k = this.nonce_generation_rfc6979(sk, h_string);\n\n    // 6. c = ECVRF_hash_points(H, Gamma, g^k, h^k)\n    const k_b = this.BASE.mul(new BigInteger(k));\n    const k_h = h.mul(new BigInteger(k));\n    const c = this.hash_points(h, gamma, k_b, k_h);\n\n    // 7. s = (k + c*x) mod q (where * denotes number multiplication)\n    const s = (k + c * BigInt(secret_scalar_x)) % BigInt(this.ORDER);\n\n    // 8. pi_string = point_to_string(Gamma) || int_to_string(c, n) || int_to_string(s, qLen)\n    const pi_string =\n      this.point_to_string(gamma) +\n      this.int_to_string(c, 16) +\n      this.int_to_string(s, 32);\n\n    // 9. Output pi_string\n    return pi_string;\n  }\n\n  // Section 5.2. ECVRF Proof To Hash\n  /**\n     * ECVRF_proof_to_hash(pi_string)\n     * @param pi_string VRF proof, octet string of length m+3n (80) bytes\n     * @return (\"VALID\", beta_string) where beta_string is the VRF hash output, octet string\n            of length hLen (64) bytes, or (\"INVALID\", []) upon failure\n     */\n  proof_to_hash(pi_string) {\n    // 1. D = ECVRF_decode_proof(pi_string)\n    // 2. If D is 'INVALID', output 'INVALID' and stop\n    const d = this.decode_proof(pi_string);\n    if (d == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 3. (Gamma, c, s) = D\n    let gamma = d[0];\n    gamma = this.string_to_bytes(this.point_to_string(gamma));\n\n    // 4. three_string = 0x03 = int_to_string(3, 1), A single octet with value 3\n    const three_string = [0x03];\n\n    // 5. beta_string = Hash(suite_string || three_string || point_to_string(cofactor * Gamma))\n    const beta_string = SHA256.create()\n      .update(this.SUITE_STRING.concat(three_string, gamma))\n      .hex();\n\n    // 6. Output beta_string\n    return beta_string;\n  }\n\n  // 5.3. ECVRF Verifying\n  /**\n     * ECVRF_verify(Y, pi_string, alpha_string)\n     * @param pk public key, an EC point\n     * @param pi_string  VRF proof, octet string of length ptLen+n+qLen\n     * @param alpha_string VRF input, octet string\n     * @return (\"VALID\", beta_string), where beta_string is the VRF hash output, octet string\n            of length hLen (64) bytes; or (\"INVALID\", []) upon failure\n     */\n  verify(pk, pi_string, alpha_string) {\n    // 1. D = ECVRF_decode_proof(pi_string)\n    // 2. If D is \"INVALID\", output \"INVALID\" and stop\n    pk = this.string_to_point(pk);\n    const d = this.decode_proof(pi_string);\n    if (d == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 3. (Gamma, c, s) = D\n    const gamma = d[0];\n    const c = d[1];\n    const s = d[2];\n\n    // 4. H = ECVRF_hash_to_curve(suite_string, pk, alpha_string)\n    const h = this.hash_to_curve_try_and_increment(\n      this.SUITE_STRING,\n      pk,\n      alpha_string\n    );\n    if (h == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 5. U = s*B - c*pk\n    const s_b = this.BASE.mul(new BigInteger(s));\n    const c_y = pk.mul(new BigInteger(c));\n    const u = s_b.add(c_y.neg());\n\n    // 6. V = s*H - c*Gamma\n    const s_h = h.mul(new BigInteger(s));\n    const c_g = gamma.mul(new BigInteger(c));\n    const v = s_h.add(c_g.neg());\n\n    // 7. c’ = ECVRF_hash_points(H, Gamma, U, V)\n    const cp = this.hash_points(h, gamma, u, v);\n\n    // 8. If c and c’ are equal, output (\"VALID\", ECVRF_proof_to_hash(pi_string)); else output \"INVALID\"\n    if (c == cp) {\n      return {\n        status: \"VALID\",\n        beta_string: this.proof_to_hash(pi_string),\n      };\n    } else {\n      return {\n        status: \"INVALID\",\n        beta_string: \"\",\n      };\n    }\n  }\n\n  ///// ECVRF Auxiliary functions\n\n  // Section 5.4.1.1.\n  /**\n     * The ECVRF_hash_to_curve algorithm takes in the VRF input alpha and\n     converts it to H, an EC point in G\n     * @param {*} suite_string A single octet specifying ECVRF ciphersuite\n     * @param {*} pk public key, an EC point\n     * @param {*} alpha_string value to be hashed, an octet string\n     * @return  H - hashed value, A finite EC point in G, or INVALID upon failure\n     */\n  hash_to_curve_try_and_increment(suite_string, pk, alpha_string) {\n    // 1. ctr = 0\n    let ctr = 0x00;\n\n    // 2. PK_string = point_to_string(Y)\n    const pk_string = this.string_to_bytes(pk.encodeCompressed(\"hex\"));\n    alpha_string = this.string_to_bytes(alpha_string);\n\n    // 3. one_string = 0x01 = int_to_string(1, 1), A single octet with value 1\n    const one_string = 0x01;\n\n    // 4. H = 'INVALID'\n    let H = \"INVALID\";\n\n    // 5. While H is \"INVALID\" or H is EC point at infinity\n    while (H == \"INVALID\" || H.isInfinity()) {\n      // A. ctr_string = int_to_string(ctr, 1)\n      // B. hash_string = Hash(suite_string || one_string || PK_string ||alpha_string || ctr_string)\n      const hash_string = SHA256.create()\n        .update([suite_string, one_string, ...pk_string, ...alpha_string, ctr])\n        .digest();\n\n      // C. H = arbitrary_string_to_point(hash_string)\n      H = this.string_to_point([0x02, ...hash_string]);\n\n      // D.  If H is not \"INVALID\" and cofactor > 1, set H = cofactor * H\n      // We can omit these step because cofactor = 1\n\n      // E. ctr = ctr + 1\n      ctr = ctr + 0x01;\n    }\n\n    // 6. Output H\n    return H;\n  }\n\n  // Section 5.4.2.1. ECVRF Nonce Generation From RFC 6979\n  /**\n   * Random nonce generation\n   * @param sk an ECVRF secret key as bytes\n   * @param h_string an octet string\n   * @return k an number between 0 and q-1\n   */\n  nonce_generation_rfc6979(sk, h_string) {\n    // a. Process m through the hash function H, yielding:\n    h_string = this.string_to_bytes(h_string);\n    let h1 = SHA256.create().update(h_string).digest();\n    h1 = this.bits2octets(h1, this.ORDER);\n    sk = this.int2octets(BigInt(\"0x\" + sk), this.ORDER.bitLength());\n\n    // b. set V = 0x01 0x01 0x01 ... 0x01 such that the length of V, in bits, is equal to 8*ceil(hlen/8).\n    let v = Array(32).fill(0x01);\n\n    // c. Set: K = 0x00 0x00 0x00 ... 0x00 such that the length of K, in bits, is equal to 8*ceil(hlen/8).\n    let k = Array(32).fill(0x00);\n\n    // d.  Set: K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1)) where '||' denotes concatenation.\n    //k = Hmac.create(k).update(v.concat(0x00, sk, h1)).digest()\n    k = Hmac.create(k).update(v).update([0x00]).update(sk).update(h1).digest();\n\n    // e. Set: V = HMAC_K(V)\n    v = Hmac.create(k).update(v).digest();\n\n    // f. Set:  K = HMAC_K(V || 0x01 || int2octets(x) || bits2octets(h1))\n    //k = Hmac.create(k).update(v.concat(0x01, sk, h1)).digest()\n    k = Hmac.create(k).update(v).update([0x01]).update(sk).update(h1).digest();\n\n    // g. Set: V = HMAC_K(V)\n    v = Hmac.create(k).update(v).digest();\n\n    // h. Apply the following algorithm until a proper value is found for k:\n    // 1. Set T to the empty sequence.  The length of T (in bits) is denoted tlen; thus, at that point, tlen = 0.\n\n    // 2.\n    while (true) {\n      v = Hmac.create(k).update(v).digest();\n      const k_int = this.bits2int(v, this.ORDER.bitLength());\n      if (k_int < BigInt(this.ORDER) - 1n) {\n        return k_int;\n      }\n      k = SHA256.hmac.create(k).update(v).update([0x00]).digest();\n\n      v = SHA256.hmac.create(k).update(v).digest();\n    }\n  }\n\n  // section 5.4.3. ECVRF Hash Points\n  /**\n   * ECVRF_hash_points(P1, P2, ..., PM)\n   * @param p1 an EC points in G\n   * @param p2 an EC points in G\n   * @param p3 an EC points in G\n   * @param p4 an EC points in G\n   * @retrun c hash value, number between 0 and 2^(8n)-1\n   */\n  hash_points(p1, p2, p3, p4) {\n    // 1. two_string = 0x02 = int_to_string(2, 1), A single octet with value 2\n    const two_string = [0x02];\n\n    // 2. Initialize str = suite_string || two_string\n    let string = this.SUITE_STRING.concat(two_string);\n\n    // 3.for PJ in [P1, P2, ... PM]:\n    // str = str || point_to_string(PJ)\n    p1 = this.string_to_bytes(this.point_to_string(p1));\n    p2 = this.string_to_bytes(this.point_to_string(p2));\n    p3 = this.string_to_bytes(this.point_to_string(p3));\n    p4 = this.string_to_bytes(this.point_to_string(p4));\n    string = string.concat(p1, p2, p3, p4);\n\n    // 4. c_string = Hash(str)\n    const c_string = this.hash(string);\n\n    // 5. truncated_c_string = c_string[0]...c_string[n-1]\n    const truncated_c_string = c_string.slice(0, 16);\n\n    // 6. c = string_to_int(truncated_c_string)\n    const c = this.string_to_int(truncated_c_string);\n\n    // 7. Output c\n    return c;\n  }\n\n  // Section 5.4.4. ECVRF Decode Proof\n  /**\n     * ECVRF_decode_proof(pi_string)\n     * @param pi_string VRF proof, octet string (ptLen+n+qLen octets)\n     * @return \"INVALID\", or \n            Gamma - EC point,\n            c - number between 0 and 2^(8n)-1,\n            s - number between 0 and 2^(8qLen)-1\n     */\n  decode_proof(pi_string) {\n    // ptLen+n+qLen octets = 33+16+32 = 81\n    pi_string = this.string_to_bytes(pi_string);\n    if (pi_string.length != 81) {\n      return \"INVALID\";\n    }\n\n    // 1. let gamma_string = pi_string[0]...p_string[ptLen-1]\n    const gamma_string = pi_string.slice(0, 33);\n\n    // let c_string = pi_string[ptLen]...pi_string[ptLen+n-1]\n    const c_string = pi_string.slice(33, 49);\n\n    // 3. let s_string =pi_string[ptLen+n]...pi_string[ptLen+n+qLen-1]\n    const s_string = pi_string.slice(49);\n\n    // 4. Gamma = string_to_point(gamma_string)\n    // 5. if Gamma = \"INVALID\" output \"INVALID\" and stop.\n    const gamma = this.string_to_point(gamma_string);\n    if (gamma == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 6. c = string_to_int(c_string)\n    const c = this.string_to_int(c_string);\n\n    // 7. s = string_to_int(s_string)\n    const s = this.string_to_int(s_string);\n\n    // 8. Output Gamma, c, and s\n    return [gamma, c, s];\n  }\n\n  computeFastVerifyParams(pk, pi_string, alpha_string) {\n    // 1. D = ECVRF_decode_proof(pi_string)\n    // 2. If D is \"INVALID\", output \"INVALID\" and stop\n    pk = this.string_to_point(pk);\n    const d = this.decode_proof(pi_string);\n    if (d == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 3. (Gamma, c, s) = D\n    const gamma = d[0];\n    const c = d[1];\n    const s = d[2];\n\n    // 4. H = ECVRF_hash_to_curve(suite_string, pk, alpha_string)\n    const h = this.hash_to_curve_try_and_increment(\n      this.SUITE_STRING,\n      pk,\n      alpha_string\n    );\n    if (h == \"INVALID\") {\n      return \"INVALID\";\n    }\n\n    // 5. U = s*B - c*pk\n    const s_b = this.BASE.mul(new BigInteger(s));\n    const c_y = pk.mul(new BigInteger(c));\n    const u = s_b.add(c_y.neg());\n\n    // 6. V = s*H - c*Gamma\n    const s_h = h.mul(new BigInteger(s));\n    const c_g = gamma.mul(new BigInteger(c));\n    const v = s_h.add(c_g.neg());\n\n    const uX = u.getX().toString(16);\n    const uY = u.getY().toString(16);\n    const vX = v.getX().toString(16);\n    const vY = v.getY().toString(16);\n    const shX = s_h.getX();\n    const shY = s_h.getY();\n    const gammaX = c_g.getX();\n    const gammaY = c_g.getY();\n    const uPoint = [uX, uY];\n    const vPoint = [vX, vY];\n    const vComponents = [shX, shY, gammaX, gammaY];\n    const hX = h.getX().toString(16);\n    const hY = h.getY().toString(16);\n    const hPoint = [hX, hY];\n\n    return {\n      uPoint,\n      vPoint,\n    };\n  }\n\n  /**\n   * Hash function\n   * @param message - An array of number\n   * @returns Hash value as an Array of number\n   */\n  hash(message) {\n    return SHA256.create().update(message).digest();\n  }\n\n  /**\n   * conversion of EC point to an ptLen-octet string  as specified in Section 5.5.\n   * @param point An EC point\n   * @returns An octet string reprasenting the EC point\n   */\n  point_to_string(point) {\n    return point.encodeCompressed(\"hex\");\n  }\n\n  /**\n    * conversion of an ptLen-octet string to EC point\n    as specified in Section 5.5. \n    * @param a_string an 32-bytes string\n    * @returns An EC point\n    */\n  string_to_point(a_string) {\n    try {\n      return this.ec.curve.decodePoint(a_string, \"hex\");\n    } catch (error) {\n      return \"INVALID\";\n    }\n  }\n\n  /**\n   * string_to_int(a_string) - conversion of an octet string to A nonnegative number as specified in Section 5.5.\n   * @param a_string An array of number representing the octect string\n   * @returns A BigInt in big endian\n   */\n  string_to_int(a_string) {\n    if (!(a_string instanceof Array))\n      a_string = this.string_to_bytes(a_string);\n    return BigInt(\n      \"0x\" + a_string.map((byte) => byte.toString(16).padStart(2, \"0\")).join(\"\")\n    );\n  }\n\n  /**\n   * int_to_string(A, len) - conversion of nonnegative number A to an octet string of length len as specified in Section 5.5.\n   * @param number A BigInteger\n   * @param len length of the string\n   * @returns A octet string in big endian\n   */\n  int_to_string(number, len) {\n    number = number.toString(16);\n    const numLen = number.length;\n    if (numLen % 2 != 0) number = \"0\" + number;\n    const bytes = this.string_to_bytes(number);\n    return bytes\n      .slice(0, len)\n      .map((byte) => byte.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n  }\n\n  /**\n   * Convert string to bytes\n   * @param octet_string  A string\n   * @returns An array of number\n   */\n  string_to_bytes(octet_string) {\n    if (!(octet_string instanceof String))\n      octet_string = octet_string.toString(16);\n    const A = [];\n    for (let i = 0; i < octet_string.length; i = i + 2) {\n      A.push(parseInt(octet_string.substr(i, 2), 16));\n    }\n    return A;\n  }\n\n  bits2octets(bits, q) {\n    const z1 = this.bits2int(bits, q.bitLength());\n    const z2 = z1 % BigInt(q);\n    return this.int2octets(z2, q.bitLength());\n  }\n\n  bits2int(bits, qLen) {\n    const bLen = bits.length * 8;\n    let integer = BigInt(\n      \"0x\" + bits.map((byte) => byte.toString(16).padStart(2, \"0\")).join(\"\")\n    );\n    if (qLen < bLen) {\n      integer = integer >> BigInt(bLen - qLen);\n    }\n    return integer;\n  }\n\n  int2octets(int, qLen) {\n    int = int.toString(16);\n    if (int.length % 2 != 0) int = \"0\" + int;\n    let octets = this.string_to_bytes(int);\n    const rLen = 8 * (qLen / 8);\n    const bLen = octets.length * 8;\n\n    if (bLen < rLen) {\n      // left pad with rlen - blen bits\n      const padNum = Math.ceil((rLen - bLen) / 8);\n      //console.log('padnum', padNum)\n      const leftPaddedBits = Array(padNum).fill(0x00, 0, padNum);\n      octets = leftPaddedBits.concat(octets);\n    }\n    if (bLen > rLen) {\n      // truncate to rlen bits\n      octets = octets.slice(0, Math.ceil(qLen / 8));\n    }\n    return octets;\n  }\n\n  hex_to_ascii(str1) {\n    var hex = str1.toString();\n    var str = \"\";\n    for (var n = 0; n < hex.length; n += 2) {\n      str += String.fromCharCode(parseInt(hex.substr(n, 2), 16));\n    }\n    return str;\n  }\n\n  ascii_to_hex(str) {\n    var arr1 = [];\n    for (var n = 0, l = str.length; n < l; n++) {\n      var hex = Number(str.charCodeAt(n)).toString(16);\n      arr1.push(hex);\n    }\n    return arr1.join(\"\");\n  }\n}\n\nfunction generateRandomHexString(length) {\n  const bytes = new Uint8Array(length / 2);\n  const _crypto = typeof window === \"undefined\" ? require(\"crypto\").webcrypto : window.crypto;\n  _crypto.getRandomValues(bytes);\n  return Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');\n}\n\n//function generateRandomString(length) {\n//  let result = '';\n//  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n//  for (let i = 0; i < length; i++) {\n//    result += characters.charAt(Math.floor(Math.random() * characters.length));\n//  }\n//  return result;\n// }\n\n\n// Formula to generate random number \nconst VrfGenerator = () => {\n  const sk = crypto.randomBytes(32).toString('hex');\n  //const sk = \"c9afa9d845ba75166b5c215767b1d6934e50c3db36e89b127b8a622b120f6721\"\n  const vrf = new VRF();\n  const piString = vrf.prove(sk, generateRandomHexString(8));\n  console.log(\"pi==>\", piString);\n  const BetaString = vrf.proof_to_hash(piString);\n  console.log(\"Beta==>\", BetaString);\n  const hash = SHA256(BetaString);\n  const hashLength = hash.length;\n  const divisor = Math.pow(2, hashLength);\n  const randomNumber = parseInt(hash, 16) / divisor;\n  return randomNumber.toString();\n};\n\n//console.log(VrfGenerator());\n\n//module.exports = VrfGenerator;\nexport default VrfGenerator;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}