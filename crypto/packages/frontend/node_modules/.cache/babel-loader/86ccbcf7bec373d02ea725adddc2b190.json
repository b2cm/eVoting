{"ast":null,"code":"import { BehaviorSubject, filter, first, firstValueFrom, fromEvent, map, mapTo, of, Subject, Subscription, switchMap, tap } from \"rxjs\";\nimport { Queue } from \"../util/queue\";\n//represents a connection with another party\n\nconst baseConfig = {\n  iceServers: [{\n    urls: \"stun:stun.l.google.com:19302\"\n  }]\n};\nexport class Party {\n  constructor(partyId, pc, channel, teardown) {\n    this.partyId = partyId;\n    this.pc = pc;\n    this.channel = channel;\n    this.teardown = teardown;\n    this._messageBuffer = new Queue();\n    this._messagesAvailable$ = new Subject();\n    //public vrfNumber : any;\n    this.ready$ = new BehaviorSubject(false);\n    this.vrf$ = new BehaviorSubject(null);\n    this._bufferMessages();\n    //this.vrfNumber = VrfGenerator();\n  }\n\n  _bufferMessages() {\n    this.channel.onmessage = _ref => {\n      let {\n        data\n      } = _ref;\n      console.log(\"message recieved from: \" + this.partyId, data);\n      try {\n        const m = JSON.parse(data);\n        if (\"ready\" in m) {\n          this.ready$.next(m.ready);\n          this.vrf$.next(m.vrfNumber);\n        } else {\n          throw new Error();\n        }\n      } catch (e) {\n        this._messageBuffer.enque(data);\n        this._messagesAvailable$.next(data);\n      }\n    };\n  }\n  // read\n  get bufferedMessage$() {\n    if (!this._messageBuffer.isEmpty()) {\n      return of(this._messageBuffer.dequeue()).pipe(filter(m => {\n        try {\n          return !(\"ready\" in JSON.parse(m));\n        } catch (e) {\n          return true;\n        }\n      }));\n    } else {\n      return this._messagesAvailable$.pipe(switchMap(() => this.bufferedMessage$), first());\n    }\n  }\n  send(data) {\n    this.channel.send(data);\n  }\n  cleanup() {\n    this.teardown.unsubscribe();\n    this.channel.close();\n    this.pc.close();\n  }\n  sendReady(ready, vrfNumber) {\n    this.channel.send(JSON.stringify({\n      ready,\n      vrfNumber\n    }));\n  }\n\n  // sendVrfNumber(vrfNumber: any) {\n  //   this.channel.send(\n  //     JSON.stringify({\n  //       vrfNumber,\n  //     })\n  //   );\n  // }\n}\n\nexport async function createParty(ourId, partyId, signaller) {\n  const pc = new RTCPeerConnection(baseConfig);\n  let makingOffer = false;\n  let ignoreOffer = false;\n  const polite = ourId.localeCompare(partyId) > 0;\n  const dataChannel$ = polite //if we are polite, wait for the other peer to create data channel\n  ? fromEvent(pc, \"datachannel\").pipe(map(_ref2 => {\n    let {\n      channel\n    } = _ref2;\n    return channel;\n  })) : of(pc.createDataChannel(\"data\"));\n  const startNegotiation$ = fromEvent(pc, \"negotiationneeded\").pipe(switchMap(async () => {\n    console.log(partyId, \"starting neg\");\n    try {\n      makingOffer = true;\n      await pc.setLocalDescription();\n      signaller.sendRTCMessage(partyId, {\n        description: pc.localDescription\n      });\n    } catch (err) {\n      console.error(err);\n    } finally {\n      makingOffer = false;\n    }\n  }));\n  const sendCandidate$ = fromEvent(pc, \"icecandidate\").pipe(tap(_ref3 => {\n    let {\n      candidate\n    } = _ref3;\n    signaller.sendRTCMessage(partyId, {\n      candidate\n    });\n  }));\n  const handleIncoming$ = signaller.recieveMessage$.pipe(filter(_ref4 => {\n    let {\n      from\n    } = _ref4;\n    return from === partyId;\n  }), tap(async _ref5 => {\n    let {\n      message: {\n        description,\n        candidate\n      }\n    } = _ref5;\n    try {\n      if (description) {\n        console.log(partyId, \"incoming neg/answer\");\n        const offerCollision = description.type === \"offer\" && (makingOffer || pc.signalingState !== \"stable\");\n        ignoreOffer = !polite && offerCollision;\n        if (ignoreOffer) {\n          return;\n        }\n        await pc.setRemoteDescription(description);\n        if (description.type === \"offer\") {\n          console.log(partyId, \"recieved offer, replying...\");\n          await pc.setLocalDescription();\n          signaller.sendRTCMessage(partyId, {\n            description: pc.localDescription\n          });\n        } else {\n          console.log(partyId, \"recieved answer\");\n        }\n      } else if (candidate) {\n        try {\n          await pc.addIceCandidate(candidate);\n        } catch (err) {\n          if (!ignoreOffer) {\n            throw err;\n          }\n        }\n      }\n    } catch (err) {\n      console.error(err);\n    }\n  }));\n  const subs = new Subscription();\n  subs.add(startNegotiation$.subscribe());\n  subs.add(handleIncoming$.subscribe());\n  subs.add(sendCandidate$.subscribe());\n  const channel = await firstValueFrom(dataChannel$.pipe(switchMap(c => c.readyState === \"open\" ? of(c) : fromEvent(c, \"open\").pipe(mapTo(c)))));\n  return new Party(partyId, pc, channel, subs);\n}","map":{"version":3,"names":["BehaviorSubject","filter","first","firstValueFrom","fromEvent","map","mapTo","of","Subject","Subscription","switchMap","tap","Queue","baseConfig","iceServers","urls","Party","constructor","partyId","pc","channel","teardown","_messageBuffer","_messagesAvailable$","ready$","vrf$","_bufferMessages","onmessage","_ref","data","console","log","m","JSON","parse","next","ready","vrfNumber","Error","e","enque","bufferedMessage$","isEmpty","dequeue","pipe","send","cleanup","unsubscribe","close","sendReady","stringify","createParty","ourId","signaller","RTCPeerConnection","makingOffer","ignoreOffer","polite","localeCompare","dataChannel$","_ref2","createDataChannel","startNegotiation$","setLocalDescription","sendRTCMessage","description","localDescription","err","error","sendCandidate$","_ref3","candidate","handleIncoming$","recieveMessage$","_ref4","from","_ref5","message","offerCollision","type","signalingState","setRemoteDescription","addIceCandidate","subs","add","subscribe","c","readyState"],"sources":["/Users/kemlohalex/Documents/evoting/crypto/packages/frontend/src/connections/party.ts"],"sourcesContent":["import {\n  BehaviorSubject,\n  filter,\n  first,\n  firstValueFrom,\n  fromEvent,\n  map,\n  mapTo,\n  Observable,\n  of,\n  Subject,\n  Subscription,\n  switchMap,\n  tap,\n} from \"rxjs\";\nimport { Queue } from \"../util/queue\";\nimport { Signaller } from \"./signalling\";\n\n\n//represents a connection with another party\n\nconst baseConfig = {\n  iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\n};\nexport class Party {\n  constructor(\n    readonly partyId: string,\n    private pc: RTCPeerConnection,\n    private channel: RTCDataChannel,\n    private teardown: Subscription\n    \n  ) {\n    this._bufferMessages();\n    //this.vrfNumber = VrfGenerator();\n  }\n  private _messageBuffer = new Queue<string>();\n  private _messagesAvailable$ = new Subject<string>();\n  //public vrfNumber : any;\n\n  readonly ready$ = new BehaviorSubject(false);\n\n  readonly vrf$ = new BehaviorSubject(null );\n\n  private _bufferMessages() {\n    this.channel.onmessage = ({ data }) => {\n      console.log(\"message recieved from: \" + this.partyId, data);\n      try {\n        const m = JSON.parse(data);\n        if (\"ready\" in m) {\n          this.ready$.next(m.ready);\n          this.vrf$.next(m.vrfNumber);\n        } else {\n          throw new Error();\n        }\n      } catch (e) {\n        this._messageBuffer.enque(data);\n        this._messagesAvailable$.next(data);\n      }\n    };\n  }\n// read\n  get bufferedMessage$(): Observable<string> {\n    if (!this._messageBuffer.isEmpty()) {\n      return of(this._messageBuffer.dequeue() as string).pipe(\n        filter((m) => {\n          try {\n            return !(\"ready\" in JSON.parse(m));\n          } catch (e) {\n            return true;\n          }\n        })\n      );\n    } else {\n      return this._messagesAvailable$.pipe(\n        switchMap(() => this.bufferedMessage$),\n        first()\n      );\n    }\n  }\n\n  send(data: string) {\n    this.channel.send(data);\n  }\n\n  cleanup() {\n    this.teardown.unsubscribe();\n    this.channel.close();\n    this.pc.close();\n  }\n\n  sendReady(ready: boolean, vrfNumber?: any) {\n    this.channel.send(\n      JSON.stringify({\n        ready,\n        vrfNumber,\n      })\n    );\n  }\n\n  // sendVrfNumber(vrfNumber: any) {\n  //   this.channel.send(\n  //     JSON.stringify({\n  //       vrfNumber,\n  //     })\n  //   );\n  // }\n}\n\nexport async function createParty(\n  ourId: string,\n  partyId: string,\n  signaller: Signaller\n) {\n  const pc = new RTCPeerConnection(baseConfig);\n  let makingOffer = false;\n  let ignoreOffer = false;\n  const polite = ourId.localeCompare(partyId) > 0;\n\n  const dataChannel$ = polite //if we are polite, wait for the other peer to create data channel\n    ? fromEvent<RTCDataChannelEvent>(pc, \"datachannel\").pipe(\n        map(({ channel }) => channel)\n      )\n    : of(pc.createDataChannel(\"data\"));\n\n  const startNegotiation$ = fromEvent(pc, \"negotiationneeded\").pipe(\n    switchMap(async () => {\n      console.log(partyId, \"starting neg\");\n      try {\n        makingOffer = true;\n        await pc.setLocalDescription();\n        signaller.sendRTCMessage(partyId, {\n          description: pc.localDescription,\n        });\n      } catch (err) {\n        console.error(err);\n      } finally {\n        makingOffer = false;\n      }\n    })\n  );\n\n  const sendCandidate$ = fromEvent<RTCPeerConnectionIceEvent>(\n    pc,\n    \"icecandidate\"\n  ).pipe(\n    tap(({ candidate }) => {\n      signaller.sendRTCMessage(partyId, { candidate });\n    })\n  );\n\n  const handleIncoming$ = signaller.recieveMessage$.pipe(\n    filter(({ from }) => from === partyId),\n    tap(async ({ message: { description, candidate } }) => {\n      try {\n        if (description) {\n          console.log(partyId, \"incoming neg/answer\");\n          const offerCollision =\n            description.type === \"offer\" &&\n            (makingOffer || pc.signalingState !== \"stable\");\n\n          ignoreOffer = !polite && offerCollision;\n          if (ignoreOffer) {\n            return;\n          }\n\n          await pc.setRemoteDescription(description);\n          if (description.type === \"offer\") {\n            console.log(partyId, \"recieved offer, replying...\");\n            await pc.setLocalDescription();\n            signaller.sendRTCMessage(partyId, {\n              description: pc.localDescription,\n            });\n          } else {\n            console.log(partyId, \"recieved answer\");\n          }\n        } else if (candidate) {\n          try {\n            await pc.addIceCandidate(candidate);\n          } catch (err) {\n            if (!ignoreOffer) {\n              throw err;\n            }\n          }\n        }\n      } catch (err) {\n        console.error(err);\n      }\n    })\n  );\n\n  const subs = new Subscription();\n  subs.add(startNegotiation$.subscribe());\n  subs.add(handleIncoming$.subscribe());\n  subs.add(sendCandidate$.subscribe());\n\n  const channel = await firstValueFrom(\n    dataChannel$.pipe(\n      switchMap((c) =>\n        c.readyState === \"open\" ? of(c) : fromEvent(c, \"open\").pipe(mapTo(c))\n      )\n    )\n  );\n\n  return new Party(partyId, pc, channel, subs);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}