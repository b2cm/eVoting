{"ast":null,"code":"export function FromhexToString(hexStr) {\n  const str = hexStr.replace(\" \", \"\");\n  return str == \"\" ? \"\" : str.match(/.{2}/g).map(byte => String.fromCharCode(parseInt(byte, 16))).join(\"\");\n}\n// This function Rotates right (circular right shift) value x by n positions\nfunction ROTR(n, x) {\n  return x >>> n | x << 32 - n;\n}\nfunction Σ0(x) {\n  return ROTR(2, x) ^ ROTR(13, x) ^ ROTR(22, x);\n}\nfunction Σ1(x) {\n  return ROTR(6, x) ^ ROTR(11, x) ^ ROTR(25, x);\n}\nfunction σ0(x) {\n  return ROTR(7, x) ^ ROTR(18, x) ^ x >>> 3;\n}\nfunction σ1(x) {\n  return ROTR(17, x) ^ ROTR(19, x) ^ x >>> 10;\n}\nfunction Ch(x, y, z) {\n  return x & y ^ ~x & z;\n} // 'choice'\nfunction Maj(x, y, z) {\n  return x & y ^ x & z ^ y & z;\n} // 'majority'\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\nexport function hash(msg, option) {\n  // >>> this oprator is for right shifting (zero-fill right shift)\n  //  a = 5;       binary   =>  00000000000000000000000000000101\n  //  b = 2;       binary   =>  00000000000000000000000000000010\n  //  a >>> b      binary   =>  00000000000000000000000000000001 => in decimal answer is 1\n  // 00000000000000000000000000000001\n  // 01000000000000000000000000000000\n  // 01000000000000000000000000000001\n  // console.log((msg.charCodeAt(2)).toString(2))\n  if (option.toLowerCase() == \"hex\") {\n    msg = FromhexToString(msg);\n  }\n  // constants\n  const K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n  // initial hash values\n  const H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n  // PREPROCESSING\n  msg += String.fromCharCode(0x80); // add trailing '1' bit (+ 0's padding) to string\n  // convert string msg into 512-bit (array of 16 32-bit integers)\n  const l = msg.length / 4 + 2; // length (in 32-bit integers) of msg + ‘1’ + appended length\n  const N = Math.ceil(l / 16); // number of 16-integer (512-bit) required to hold 'l' ints\n  const M = new Array(N); // message M is N×16 array of 32-bit integers\n  let fullStr = \"\";\n  let binaryStr;\n  for (let i = 0; i < N; i++) {\n    M[i] = new Array(16);\n    for (let j = 0; j < 16; j++) {\n      // encode 4 chars per integer (64 per chunk), big-endian encoding\n      M[i][j] = msg.charCodeAt(i * 64 + j * 4 + 0) << 24 | msg.charCodeAt(i * 64 + j * 4 + 1) << 16 | msg.charCodeAt(i * 64 + j * 4 + 2) << 8 | msg.charCodeAt(i * 64 + j * 4 + 3) << 0;\n    } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n  }\n  // 00100000 a\n  // 10000011 b\n  // 00111100 c\n  // 00100000 d\n  // << LEFT SHIFT\n  // 0010000 00000000 00000000 00000000\n  // 0000000 10000011 00000000 00000000\n  // 0000000 00000000 00111100 00000000\n  // 0000000 00000000 00000000 00100000\n  // OR\n  // 0010000 10000011 00111100 00100000\n  // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n  // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n  // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n  const lenHi = (msg.length - 1) * 8 / Math.pow(2, 32);\n  // console.log(Math.floor(lenHi));\n  const lenLo = (msg.length - 1) * 8 >>> 0;\n  // console.log(lenLo);\n  M[N - 1][14] = Math.floor(lenHi);\n  M[N - 1][15] = lenLo;\n  // console.log(\"Number of chunks required to hold the message bits: \", N);\n  // console.log(\n  // \t\"\\nMessage after converting in binary + padded bits + message length info in the last 64-bits:\"\n  // );\n  // console.log(\n  // \t\"_______________________________________________________________\"\n  // );\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < 16; j++) {\n      // encode 4 chars per integer (64 per chunks), big-endian encoding\n      if (M[i][j] < 0) binaryStr = (M[i][j] * -1).toString(2);else binaryStr = M[i][j].toString(2);\n      while (binaryStr.length < 32) {\n        binaryStr = \"0\" + binaryStr;\n      }\n      fullStr += binaryStr;\n      // process.stdout.write(binaryStr);\n    } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n  }\n  // console.log(\"\\n\\nMessage Divided in Chunks: \");\n  // console.log(\n  // \t\"_______________________________________________________________\"\n  // );\n  for (let i = 0; i < N; i++) {\n    // console.log(\"\\nChunks:\", i);\n    for (let j = 0; j < 16; j++) {\n      // encode 4 chars per integer (64 per chunk), big-endian encoding\n      if (M[i][j] < 0) binaryStr = (M[i][j] * -1).toString(2);else binaryStr = M[i][j].toString(2);\n      while (binaryStr.length < 32) {\n        binaryStr = \"0\" + binaryStr;\n      }\n      fullStr += binaryStr;\n      // process.stdout.write(binaryStr);\n    } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n  }\n  // console.log(\n  // \t\"\\n\\n__________________CONSTANTS & Initial HASHES_______________________\"\n  // );\n  // console.log(\"\\n\\nConstants :\", K);\n  // console.log(\"\\n\\nInitial HASH Values :\", H);\n  // console.log(\n  // \t\"_______________________________________________________________\"\n  // );\n  // HASH COMPUTATION\n  for (let i = 0; i < N; i++) {\n    // console.log(\"\\n\\nProcesssing Chunks:\", i);\n    // console.log(\n    // \t\"_______________________________________________________________\"\n    // );\n    const W = new Array(64);\n    // console.log(\"1 - Prepare message schedule: \");\n    for (let t = 0; t < 16; t++) {\n      W[t] = M[i][t];\n      if (W[t] < 0) binaryStr = (W[t] * -1).toString(2);else binaryStr = W[t].toString(2);\n      while (binaryStr.length < 32) {\n        binaryStr = \"0\" + binaryStr;\n      }\n      // console.log(t, binaryStr);\n    }\n    // console.log(\"Use message schedule formula for rest of 48 rounds: \");\n    for (let t = 16; t < 64; t++) {\n      W[t] = σ1(W[t - 2]) + W[t - 7] + σ0(W[t - 15]) + W[t - 16] >>> 0;\n      if (W[t] < 0) binaryStr = (W[t] * -1).toString(2);else binaryStr = W[t].toString(2);\n      while (binaryStr.length < 32) {\n        binaryStr = \"0\" + binaryStr;\n      }\n      // console.log(t, binaryStr);\n    }\n    // console.log(\n    // \t\"\\n2 - InitialiZe working variables a, b, c, d, e, f, g, h with previous hash value:\"\n    // );\n    let a = H[0],\n      b = H[1],\n      c = H[2],\n      d = H[3],\n      e = H[4],\n      f = H[5],\n      g = H[6],\n      h = H[7];\n    // console.log(\n    // \t\"a =>\",\n    // \ta.toString(2),\n    // \t\"\\nb =>\",\n    // \tb.toString(2),\n    // \t\"\\nc =>\",\n    // \tc.toString(2),\n    // \t\"\\nd =>\",\n    // \td.toString(2),\n    // \t\"\\ne =>\",\n    // \te.toString(2),\n    // \t\"\\nf =>\",\n    // \tf.toString(2),\n    // \t\"\\ng =>\",\n    // \tg.toString(2),\n    // \t\"\\nh =>\",\n    // \th.toString(2)\n    // );\n    // 3 - main loop (note '>>> 0' for 'addition modulo 2^32')\n    const T1 = h + Σ1(e) + Ch(e, f, g) + K[0] + W[0];\n    const T2 = Σ0(a) + Maj(a, b, c);\n    h = g;\n    g = f;\n    f = e;\n    e = d + T1 >>> 0;\n    d = c;\n    c = b;\n    b = a;\n    a = T1 + T2 >>> 0;\n    // console.log(\n    // \t\"\\nUpdated variables a, b, c, d, e, f, g, h after FIRST Iteration:\"\n    // );\n    // console.log(\n    // \t\"a =>\",\n    // \ta.toString(2),\n    // \t\"\\nb =>\",\n    // \tb.toString(2),\n    // \t\"\\nc =>\",\n    // \tc.toString(2),\n    // \t\"\\nd =>\",\n    // \td.toString(2),\n    // \t\"\\ne =>\",\n    // \te.toString(2),\n    // \t\"\\nf =>\",\n    // \tf.toString(2),\n    // \t\"\\ng =>\",\n    // \tg.toString(2),\n    // \t\"\\nh =>\",\n    // \th.toString(2)\n    // );\n    for (let t = 1; t < 64; t++) {\n      const T1 = h + Σ1(e) + Ch(e, f, g) + K[t] + W[t];\n      const T2 = Σ0(a) + Maj(a, b, c);\n      h = g;\n      g = f;\n      f = e;\n      e = d + T1 >>> 0;\n      d = c;\n      c = b;\n      b = a;\n      a = T1 + T2 >>> 0;\n    }\n    // console.log(\n    // \t\"\\nUpdated variables a, b, c, d, e, f, g, h AFTER 64 ITERATIONS\"\n    // );\n    // console.log(\n    // \t\"a =>\",\n    // \ta.toString(2),\n    // \t\"\\nb =>\",\n    // \tb.toString(2),\n    // \t\"\\nc =>\",\n    // \tc.toString(2),\n    // \t\"\\nd =>\",\n    // \td.toString(2),\n    // \t\"\\ne =>\",\n    // \te.toString(2),\n    // \t\"\\nf =>\",\n    // \tf.toString(2),\n    // \t\"\\ng =>\",\n    // \tg.toString(2),\n    // \t\"\\nh =>\",\n    // \th.toString(2)\n    // );\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n    H[5] = H[5] + f >>> 0;\n    H[6] = H[6] + g >>> 0;\n    H[7] = H[7] + h >>> 0;\n    // console.log(\"\\nCompute the new intermediate hash value: \");\n    // console.log(\n    // \t\"H0 =>\",\n    // \tH[0].toString(2),\n    // \t\"\\nH1 =>\",\n    // \tH[1].toString(2),\n    // \t\"\\nH2 =>\",\n    // \tH[2].toString(2),\n    // \t\"\\nH3 =>\",\n    // \tH[3].toString(2),\n    // \t\"\\nH4 =>\",\n    // \tH[4].toString(2),\n    // \t\"\\nH5 =>\",\n    // \tH[5].toString(2),\n    // \t\"\\nH6 =>\",\n    // \tH[6].toString(2),\n    // \t\"\\nH7 =>\",\n    // \tH[7].toString(2)\n    // );\n  }\n  // convert H0..H7 to hex strings (with leading zeros)\n  for (let h = 0; h < H.length; h++) H[h] = (\"00000000\" + H[h].toString(16)).slice(-8);\n  // concatenate H0..H7 in one string and return\n  return H.join(\"\");\n}","map":{"version":3,"sources":["../../src/hash.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["export function FromhexToString(hexStr) {\n    const str = hexStr.replace(\" \", \"\");\n    return str == \"\"\n        ? \"\"\n        : str\n            .match(/.{2}/g)\n            .map((byte) => String.fromCharCode(parseInt(byte, 16)))\n            .join(\"\");\n}\n// This function Rotates right (circular right shift) value x by n positions\nfunction ROTR(n, x) {\n    return (x >>> n) | (x << (32 - n));\n}\nfunction Σ0(x) {\n    return ROTR(2, x) ^ ROTR(13, x) ^ ROTR(22, x);\n}\nfunction Σ1(x) {\n    return ROTR(6, x) ^ ROTR(11, x) ^ ROTR(25, x);\n}\nfunction σ0(x) {\n    return ROTR(7, x) ^ ROTR(18, x) ^ (x >>> 3);\n}\nfunction σ1(x) {\n    return ROTR(17, x) ^ ROTR(19, x) ^ (x >>> 10);\n}\nfunction Ch(x, y, z) {\n    return (x & y) ^ (~x & z);\n} // 'choice'\nfunction Maj(x, y, z) {\n    return (x & y) ^ (x & z) ^ (y & z);\n} // 'majority'\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\nexport function hash(msg, option) {\n    // >>> this oprator is for right shifting (zero-fill right shift)\n    //  a = 5;       binary   =>  00000000000000000000000000000101\n    //  b = 2;       binary   =>  00000000000000000000000000000010\n    //  a >>> b      binary   =>  00000000000000000000000000000001 => in decimal answer is 1\n    // 00000000000000000000000000000001\n    // 01000000000000000000000000000000\n    // 01000000000000000000000000000001\n    // console.log((msg.charCodeAt(2)).toString(2))\n    if (option.toLowerCase() == \"hex\") {\n        msg = FromhexToString(msg);\n    }\n    // constants\n    const K = [\n        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n        0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n        0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n        0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n        0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n        0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n    ];\n    // initial hash values\n    const H = [\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c,\n        0x1f83d9ab, 0x5be0cd19,\n    ];\n    // PREPROCESSING\n    msg += String.fromCharCode(0x80); // add trailing '1' bit (+ 0's padding) to string\n    // convert string msg into 512-bit (array of 16 32-bit integers)\n    const l = msg.length / 4 + 2; // length (in 32-bit integers) of msg + ‘1’ + appended length\n    const N = Math.ceil(l / 16); // number of 16-integer (512-bit) required to hold 'l' ints\n    const M = new Array(N); // message M is N×16 array of 32-bit integers\n    let fullStr = \"\";\n    let binaryStr;\n    for (let i = 0; i < N; i++) {\n        M[i] = new Array(16);\n        for (let j = 0; j < 16; j++) {\n            // encode 4 chars per integer (64 per chunk), big-endian encoding\n            M[i][j] =\n                (msg.charCodeAt(i * 64 + j * 4 + 0) << 24) |\n                    (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                    (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) |\n                    (msg.charCodeAt(i * 64 + j * 4 + 3) << 0);\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // 00100000 a\n    // 10000011 b\n    // 00111100 c\n    // 00100000 d\n    // << LEFT SHIFT\n    // 0010000 00000000 00000000 00000000\n    // 0000000 10000011 00000000 00000000\n    // 0000000 00000000 00111100 00000000\n    // 0000000 00000000 00000000 00100000\n    // OR\n    // 0010000 10000011 00111100 00100000\n    // add length (in bits) into final pair of 32-bit integers (big-endian) [§5.1.1]\n    // note: most significant word would be (len-1)*8 >>> 32, but since JS converts\n    // bitwise-op args to 32 bits, we need to simulate this by arithmetic operators\n    const lenHi = ((msg.length - 1) * 8) / Math.pow(2, 32);\n    // console.log(Math.floor(lenHi));\n    const lenLo = ((msg.length - 1) * 8) >>> 0;\n    // console.log(lenLo);\n    M[N - 1][14] = Math.floor(lenHi);\n    M[N - 1][15] = lenLo;\n    // console.log(\"Number of chunks required to hold the message bits: \", N);\n    // console.log(\n    // \t\"\\nMessage after converting in binary + padded bits + message length info in the last 64-bits:\"\n    // );\n    // console.log(\n    // \t\"_______________________________________________________________\"\n    // );\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < 16; j++) {\n            // encode 4 chars per integer (64 per chunks), big-endian encoding\n            if (M[i][j] < 0)\n                binaryStr = (M[i][j] * -1).toString(2);\n            else\n                binaryStr = M[i][j].toString(2);\n            while (binaryStr.length < 32) {\n                binaryStr = \"0\" + binaryStr;\n            }\n            fullStr += binaryStr;\n            // process.stdout.write(binaryStr);\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // console.log(\"\\n\\nMessage Divided in Chunks: \");\n    // console.log(\n    // \t\"_______________________________________________________________\"\n    // );\n    for (let i = 0; i < N; i++) {\n        // console.log(\"\\nChunks:\", i);\n        for (let j = 0; j < 16; j++) {\n            // encode 4 chars per integer (64 per chunk), big-endian encoding\n            if (M[i][j] < 0)\n                binaryStr = (M[i][j] * -1).toString(2);\n            else\n                binaryStr = M[i][j].toString(2);\n            while (binaryStr.length < 32) {\n                binaryStr = \"0\" + binaryStr;\n            }\n            fullStr += binaryStr;\n            // process.stdout.write(binaryStr);\n        } // note running off the end of msg is ok 'cos bitwise ops on NaN return 0\n    }\n    // console.log(\n    // \t\"\\n\\n__________________CONSTANTS & Initial HASHES_______________________\"\n    // );\n    // console.log(\"\\n\\nConstants :\", K);\n    // console.log(\"\\n\\nInitial HASH Values :\", H);\n    // console.log(\n    // \t\"_______________________________________________________________\"\n    // );\n    // HASH COMPUTATION\n    for (let i = 0; i < N; i++) {\n        // console.log(\"\\n\\nProcesssing Chunks:\", i);\n        // console.log(\n        // \t\"_______________________________________________________________\"\n        // );\n        const W = new Array(64);\n        // console.log(\"1 - Prepare message schedule: \");\n        for (let t = 0; t < 16; t++) {\n            W[t] = M[i][t];\n            if (W[t] < 0)\n                binaryStr = (W[t] * -1).toString(2);\n            else\n                binaryStr = W[t].toString(2);\n            while (binaryStr.length < 32) {\n                binaryStr = \"0\" + binaryStr;\n            }\n            // console.log(t, binaryStr);\n        }\n        // console.log(\"Use message schedule formula for rest of 48 rounds: \");\n        for (let t = 16; t < 64; t++) {\n            W[t] = (σ1(W[t - 2]) + W[t - 7] + σ0(W[t - 15]) + W[t - 16]) >>> 0;\n            if (W[t] < 0)\n                binaryStr = (W[t] * -1).toString(2);\n            else\n                binaryStr = W[t].toString(2);\n            while (binaryStr.length < 32) {\n                binaryStr = \"0\" + binaryStr;\n            }\n            // console.log(t, binaryStr);\n        }\n        // console.log(\n        // \t\"\\n2 - InitialiZe working variables a, b, c, d, e, f, g, h with previous hash value:\"\n        // );\n        let a = H[0], b = H[1], c = H[2], d = H[3], e = H[4], f = H[5], g = H[6], h = H[7];\n        // console.log(\n        // \t\"a =>\",\n        // \ta.toString(2),\n        // \t\"\\nb =>\",\n        // \tb.toString(2),\n        // \t\"\\nc =>\",\n        // \tc.toString(2),\n        // \t\"\\nd =>\",\n        // \td.toString(2),\n        // \t\"\\ne =>\",\n        // \te.toString(2),\n        // \t\"\\nf =>\",\n        // \tf.toString(2),\n        // \t\"\\ng =>\",\n        // \tg.toString(2),\n        // \t\"\\nh =>\",\n        // \th.toString(2)\n        // );\n        // 3 - main loop (note '>>> 0' for 'addition modulo 2^32')\n        const T1 = h + Σ1(e) + Ch(e, f, g) + K[0] + W[0];\n        const T2 = Σ0(a) + Maj(a, b, c);\n        h = g;\n        g = f;\n        f = e;\n        e = (d + T1) >>> 0;\n        d = c;\n        c = b;\n        b = a;\n        a = (T1 + T2) >>> 0;\n        // console.log(\n        // \t\"\\nUpdated variables a, b, c, d, e, f, g, h after FIRST Iteration:\"\n        // );\n        // console.log(\n        // \t\"a =>\",\n        // \ta.toString(2),\n        // \t\"\\nb =>\",\n        // \tb.toString(2),\n        // \t\"\\nc =>\",\n        // \tc.toString(2),\n        // \t\"\\nd =>\",\n        // \td.toString(2),\n        // \t\"\\ne =>\",\n        // \te.toString(2),\n        // \t\"\\nf =>\",\n        // \tf.toString(2),\n        // \t\"\\ng =>\",\n        // \tg.toString(2),\n        // \t\"\\nh =>\",\n        // \th.toString(2)\n        // );\n        for (let t = 1; t < 64; t++) {\n            const T1 = h + Σ1(e) + Ch(e, f, g) + K[t] + W[t];\n            const T2 = Σ0(a) + Maj(a, b, c);\n            h = g;\n            g = f;\n            f = e;\n            e = (d + T1) >>> 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (T1 + T2) >>> 0;\n        }\n        // console.log(\n        // \t\"\\nUpdated variables a, b, c, d, e, f, g, h AFTER 64 ITERATIONS\"\n        // );\n        // console.log(\n        // \t\"a =>\",\n        // \ta.toString(2),\n        // \t\"\\nb =>\",\n        // \tb.toString(2),\n        // \t\"\\nc =>\",\n        // \tc.toString(2),\n        // \t\"\\nd =>\",\n        // \td.toString(2),\n        // \t\"\\ne =>\",\n        // \te.toString(2),\n        // \t\"\\nf =>\",\n        // \tf.toString(2),\n        // \t\"\\ng =>\",\n        // \tg.toString(2),\n        // \t\"\\nh =>\",\n        // \th.toString(2)\n        // );\n        H[0] = (H[0] + a) >>> 0;\n        H[1] = (H[1] + b) >>> 0;\n        H[2] = (H[2] + c) >>> 0;\n        H[3] = (H[3] + d) >>> 0;\n        H[4] = (H[4] + e) >>> 0;\n        H[5] = (H[5] + f) >>> 0;\n        H[6] = (H[6] + g) >>> 0;\n        H[7] = (H[7] + h) >>> 0;\n        // console.log(\"\\nCompute the new intermediate hash value: \");\n        // console.log(\n        // \t\"H0 =>\",\n        // \tH[0].toString(2),\n        // \t\"\\nH1 =>\",\n        // \tH[1].toString(2),\n        // \t\"\\nH2 =>\",\n        // \tH[2].toString(2),\n        // \t\"\\nH3 =>\",\n        // \tH[3].toString(2),\n        // \t\"\\nH4 =>\",\n        // \tH[4].toString(2),\n        // \t\"\\nH5 =>\",\n        // \tH[5].toString(2),\n        // \t\"\\nH6 =>\",\n        // \tH[6].toString(2),\n        // \t\"\\nH7 =>\",\n        // \tH[7].toString(2)\n        // );\n    }\n    // convert H0..H7 to hex strings (with leading zeros)\n    for (let h = 0; h < H.length; h++)\n        H[h] = (\"00000000\" + H[h].toString(16)).slice(-8);\n    // concatenate H0..H7 in one string and return\n    return H.join(\"\");\n}\n//# sourceMappingURL=hash.js.map"]},"metadata":{},"sourceType":"module"}