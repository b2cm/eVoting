{"ast":null,"code":"import * as bigintCryptoUtils from \"bigint-crypto-utils\";\nexport function RandomBnd(n) {\n  return bigintCryptoUtils.randBetween(n);\n}\nexport const prime = bigintCryptoUtils.prime;\nexport const PowerMod = bigintCryptoUtils.modPow;\nexport const InvMod = bigintCryptoUtils.modInv;\nexport function factorial(n) {\n  if (n < 1) {\n    throw new Error(\"Cannot evaluate factorial of negative number\");\n  }\n  let curr = n;\n  let f = 1n;\n  while (curr > 1) {\n    f = f * BigInt(curr--);\n  }\n  return f;\n}\nexport function Gen_Coprime(n) {\n  let ret;\n  while (true) {\n    ret = RandomBnd(n);\n    if (GCD(ret, n) == 1) {\n      return ret;\n    }\n  }\n}\nexport function GCD(a, b) {\n  if (a == 0) return b;\n  return GCD(modulus(b, a), a);\n}\nexport function modulus(a, b) {\n  if (b === 0n) return b;\n  return (a % b + b) % b;\n}\nexport function MulMod(a, b, n) {\n  return modulus(a * b, n);\n}\nexport function coefficient_generation(PP, nParties) {\n  const t = Math.floor((nParties - 1) / 2);\n  const p = generate_polynomial(t, PP);\n  const pp = generate_polynomial(t, PP);\n  const q = generate_polynomial(t, PP);\n  const qq = generate_polynomial(t, PP);\n  const h = generate_polynomial(t * 2, PP);\n  const hh = generate_polynomial(t * 2, PP);\n  return [p, pp, q, qq, h, hh];\n}\nexport function pick_pq() {\n  let i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  let keyLength = arguments.length > 1 ? arguments[1] : undefined;\n  let pq = 2n;\n  if (i === 1) {\n    while (MulMod(pq, 1n, 4n) !== 3n || pq - 2n ** (keyLength - 1n) <= 0) {\n      pq = RandomBnd(2n ** keyLength);\n    }\n  } else {\n    while (MulMod(pq, 1n, 4n) !== 0n || pq - 2n ** (keyLength - 1n) <= 0) {\n      pq = RandomBnd(2n ** keyLength);\n    }\n  }\n  return pq;\n}\nexport function compute_tuple(j, PP, pi, qi, _ref) {\n  let [p, pp, q, qq, h, hh] = _ref;\n  let pij = (pi + evaluate_polynomial(p, j)) % PP;\n  let qij = (qi + evaluate_polynomial(q, j)) % PP;\n  let hij = (0n + evaluate_polynomial(h, j)) % PP;\n  return [pij, qij, hij];\n}\nexport function evaluate_polynomial(coeff, x) {\n  let curr = 1n;\n  return coeff.reduce((ans, c) => {\n    curr = curr * x;\n    return ans + c * curr;\n  }, 0n);\n}\nexport function generate_polynomial(n, bound) {\n  const c = Array(n);\n  for (const idx of c.keys()) {\n    c[idx] = RandomBnd(bound);\n  }\n  return c;\n}\nexport function Jacobi(a, n) {\n  if (a >= n) a %= n;\n  let result = 1;\n  while (a) {\n    //@ts-ignore\n    while ((a & 1n) === 0) {\n      a >>= 1n;\n      //@ts-ignore\n      if ((n & 7n) === 3 || (n & 7n) === 5n) result = -result;\n    }\n    let t = a;\n    a = n;\n    n = t;\n    if ((a & 3n) === 3n && (n & 3n) === 3n) result = -result;\n    a %= n;\n  }\n  if (n === 1n) return result;\n  return 0;\n}","map":{"version":3,"sources":["../../src/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as bigintCryptoUtils from \"bigint-crypto-utils\";\nexport function RandomBnd(n) {\n    return bigintCryptoUtils.randBetween(n);\n}\nexport const prime = bigintCryptoUtils.prime;\nexport const PowerMod = bigintCryptoUtils.modPow;\nexport const InvMod = bigintCryptoUtils.modInv;\nexport function factorial(n) {\n    if (n < 1) {\n        throw new Error(\"Cannot evaluate factorial of negative number\");\n    }\n    let curr = n;\n    let f = 1n;\n    while (curr > 1) {\n        f = f * BigInt(curr--);\n    }\n    return f;\n}\nexport function Gen_Coprime(n) {\n    let ret;\n    while (true) {\n        ret = RandomBnd(n);\n        if (GCD(ret, n) == 1) {\n            return ret;\n        }\n    }\n}\nexport function GCD(a, b) {\n    if (a == 0)\n        return b;\n    return GCD(modulus(b, a), a);\n}\nexport function modulus(a, b) {\n    if (b === 0n)\n        return b;\n    return ((a % b) + b) % b;\n}\nexport function MulMod(a, b, n) {\n    return modulus(a * b, n);\n}\nexport function coefficient_generation(PP, nParties) {\n    const t = Math.floor((nParties - 1) / 2);\n    const p = generate_polynomial(t, PP);\n    const pp = generate_polynomial(t, PP);\n    const q = generate_polynomial(t, PP);\n    const qq = generate_polynomial(t, PP);\n    const h = generate_polynomial(t * 2, PP);\n    const hh = generate_polynomial(t * 2, PP);\n    return [p, pp, q, qq, h, hh];\n}\nexport function pick_pq(i = 1, keyLength) {\n    let pq = 2n;\n    if (i === 1) {\n        while (MulMod(pq, 1n, 4n) !== 3n || pq - 2n ** (keyLength - 1n) <= 0) {\n            pq = RandomBnd(2n ** keyLength);\n        }\n    }\n    else {\n        while (MulMod(pq, 1n, 4n) !== 0n || pq - 2n ** (keyLength - 1n) <= 0) {\n            pq = RandomBnd(2n ** keyLength);\n        }\n    }\n    return pq;\n}\nexport function compute_tuple(j, PP, pi, qi, [p, pp, q, qq, h, hh]) {\n    let pij = (pi + evaluate_polynomial(p, j)) % PP;\n    let qij = (qi + evaluate_polynomial(q, j)) % PP;\n    let hij = (0n + evaluate_polynomial(h, j)) % PP;\n    return [pij, qij, hij];\n}\nexport function evaluate_polynomial(coeff, x) {\n    let curr = 1n;\n    return coeff.reduce((ans, c) => {\n        curr = curr * x;\n        return ans + c * curr;\n    }, 0n);\n}\nexport function generate_polynomial(n, bound) {\n    const c = Array(n);\n    for (const idx of c.keys()) {\n        c[idx] = RandomBnd(bound);\n    }\n    return c;\n}\nexport function Jacobi(a, n) {\n    if (a >= n)\n        a %= n;\n    let result = 1;\n    while (a) {\n        //@ts-ignore\n        while ((a & 1n) === 0) {\n            a >>= 1n;\n            //@ts-ignore\n            if ((n & 7n) === 3 || (n & 7n) === 5n)\n                result = -result;\n        }\n        let t = a;\n        a = n;\n        n = t;\n        if ((a & 3n) === 3n && (n & 3n) === 3n)\n            result = -result;\n        a %= n;\n    }\n    if (n === 1n)\n        return result;\n    return 0;\n}\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"module"}