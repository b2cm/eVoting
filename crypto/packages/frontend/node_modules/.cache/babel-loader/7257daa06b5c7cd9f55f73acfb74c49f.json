{"ast":null,"code":"import { CURVE, _0n, _1n, _4n } from './constant';\nimport { intToBinary } from './utils';\nexport default class ModMath {\n  static weistrass(x) {\n    const {\n      a,\n      b\n    } = CURVE;\n    const x2 = ModMath.mod(x * x);\n    const x3 = ModMath.mod(x2 * x);\n    return ModMath.mod(x3 + a * x + b);\n  }\n}\nModMath.mod = function (a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const result = a % b;\n  return result >= 0 ? result : result + b;\n};\nModMath.invert = function (a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  if (a === _0n || b <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${a} mod=${b}`);\n  }\n  let r2 = ModMath.mod(a, b);\n  let r1 = b;\n  let t1 = _0n;\n  let t2 = _1n;\n  let t;\n  let r;\n  while (r2 > 0) {\n    let q = r1 / r2;\n    r = r1 % r2;\n    t = t1 - q * t2;\n    r1 = r2;\n    r2 = r;\n    t1 = t2;\n    t2 = t;\n  }\n  if (r1 !== _1n) {\n    throw new Error(`invert doesn't not exist on ${a.toString()}`);\n  }\n  return ModMath.mod(t1, b);\n};\nModMath.pow = function (a, expo) {\n  let mod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : CURVE.P;\n  const bin = intToBinary(expo);\n  let ret = a;\n  for (let i = 1; i < bin.length; i++) {\n    ret = ModMath.mod(ret * ret, mod);\n    if (bin[i]) {\n      ret = ModMath.mod(ret * a, mod);\n    }\n  }\n  return ret;\n};\nModMath.sqrt = function (a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  return ModMath.pow(a, (b + _1n) / _4n, b);\n};","map":{"version":3,"sources":["../../../src/mod-math.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { CURVE, _0n, _1n, _4n } from './constant';\nimport { intToBinary } from './utils';\nexport default class ModMath {\n    static weistrass(x) {\n        const { a, b } = CURVE;\n        const x2 = ModMath.mod(x * x);\n        const x3 = ModMath.mod(x2 * x);\n        return ModMath.mod(x3 + a * x + b);\n    }\n}\nModMath.mod = (a, b = CURVE.P) => {\n    const result = a % b;\n    return result >= 0 ? result : result + b;\n};\nModMath.invert = (a, b = CURVE.P) => {\n    if (a === _0n || b <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${a} mod=${b}`);\n    }\n    let r2 = ModMath.mod(a, b);\n    let r1 = b;\n    let t1 = _0n;\n    let t2 = _1n;\n    let t;\n    let r;\n    while (r2 > 0) {\n        let q = r1 / r2;\n        r = r1 % r2;\n        t = t1 - q * t2;\n        r1 = r2;\n        r2 = r;\n        t1 = t2;\n        t2 = t;\n    }\n    if (r1 !== _1n) {\n        throw new Error(`invert doesn't not exist on ${a.toString()}`);\n    }\n    return ModMath.mod(t1, b);\n};\nModMath.pow = (a, expo, mod = CURVE.P) => {\n    const bin = intToBinary(expo);\n    let ret = a;\n    for (let i = 1; i < bin.length; i++) {\n        ret = ModMath.mod(ret * ret, mod);\n        if (bin[i]) {\n            ret = ModMath.mod(ret * a, mod);\n        }\n    }\n    return ret;\n};\nModMath.sqrt = (a, b = CURVE.P) => ModMath.pow(a, (b + _1n) / _4n, b);\n//# sourceMappingURL=mod-math.js.map"]},"metadata":{},"sourceType":"module"}