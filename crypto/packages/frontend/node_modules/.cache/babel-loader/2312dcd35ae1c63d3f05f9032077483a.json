{"ast":null,"code":"import { encrypt } from \".\";\nimport { Gen_Coprime, InvMod, MulMod, PowerMod, RandomBnd } from \"./util\";\nimport { generator } from \"./generator\";\nimport { hash } from \"./hash\";\nimport { get_l, get_t } from \"./t\";\nimport { getK } from \"./K\";\nimport { ethers } from 'ethers';\nexport function createMemberShipZKP(message, validMessages, N) {\n  let bits = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 256n;\n  const r = Gen_Coprime(N);\n  const cipher = encrypt(message, N, r);\n  const epsilon = Gen_Coprime(N);\n  const ui = PowerMod(epsilon, N, N * N);\n  let i;\n  const us = [],\n    es = [],\n    vs = [];\n  for (const [idx, validMessage] of validMessages.entries()) {\n    //Working variables\n    const gmk = PowerMod(generator(N), validMessage, N * N);\n    const uk = cipher * InvMod(gmk, N * N) % (N * N);\n    if (message != validMessage) {\n      //confirm these two\n      //zk\n      const vj = Gen_Coprime(N);\n      //ek\n      const ej = Gen_Coprime(N);\n      const vn = PowerMod(vj, N, N * N);\n      const ue = PowerMod(uk, ej, N * N);\n      const uj = vn * InvMod(ue, N * N) % (N * N);\n      us.push(uj);\n      vs.push(vj);\n      es.push(ej);\n    } else {\n      us.push(ui);\n      vs.push(0n);\n      es.push(0n);\n      i = idx;\n    }\n  }\n  const uHash = BigInt(\"0x\" + hash(BigInt(us.join(\"\")).toString(16), \"hex\")) % N;\n  const eSum = es.filter(e => e != 0n).reduce((acc, e) => (acc + e) % N, 0n);\n  const ei = (uHash - eSum) % N;\n  //Also confirm this\n  const rep = PowerMod(r, ei, N);\n  const vi = epsilon * rep * PowerMod(generator(N), ei, N) % N;\n  es[i] = ei;\n  vs[i] = vi;\n  return [cipher, [es, us, vs]];\n}\nexport function computeZKPInputs(ciphertext,\n//[es, us, vs]: [bigint[], bigint[], bigint[]],\nproof, validMessages, N) {\n  const e = BigInt(\"0x\" + hash(BigInt(proof[1].join(\"\")).toString(16), \"hex\")) % N;\n  let ukInv = []; // Array containing the modular inverse of uk for each message.\n  let gmk = [];\n  const as = validMessages.map(m => {\n    const _gmk = PowerMod(generator(N), m, N * N);\n    gmk.push(ethers.utils.hexlify(_gmk));\n    const uk = InvMod(_gmk, N * N);\n    const _uk = ciphertext * InvMod(_gmk, N * N) % (N * N);\n    const uki = InvMod(_uk, N * N); // Modular inverse of _uk\n    ukInv.push(ethers.utils.hexlify(uki));\n    return ethers.utils.hexlify(uk);\n  });\n  const isProofONegativ = proof[0].map(e => {\n    if (e < 0n) {\n      return true;\n    }\n    return false;\n  });\n  const p = proof.map((elem, i) => elem.map((value, j) => {\n    if (value < 0n) {\n      //console.log(`value at index ${i}:${j}`, value);\n      return ethers.utils.hexlify(value * -1n);\n    }\n    return ethers.utils.hexlify(value);\n  }));\n  return {\n    proof: p,\n    isProofONegativ,\n    as,\n    ias: ukInv,\n    gmk,\n    e: ethers.utils.hexlify(e)\n  };\n}\nexport function verifyMembershipZkp(ciphertext, _ref, validMessages, N) {\n  let [es, us, vs] = _ref;\n  const e = BigInt(\"0x\" + hash(BigInt(us.join(\"\")).toString(16), \"hex\")) % N;\n  const as = validMessages.map(m => {\n    const gmk = PowerMod(generator(N), m, N * N);\n    const uk = ciphertext * InvMod(gmk, N * N) % (N * N);\n    return uk;\n  });\n  const eSum = es.reduce((acc, e) => (acc + e) % N, 0n);\n  if (eSum != e) {\n    return false;\n  }\n  return vs.every((v, idx) => {\n    const ui = us[idx];\n    const ei = es[idx];\n    const ai = as[idx];\n    const vin = PowerMod(v, N, N * N);\n    const aie = PowerMod(ai, ei, N * N);\n    const uiae = ui * aie % (N * N);\n    return vin == uiae;\n  });\n}\nexport function ZKP_gen_R(c, N, vk, delta, keyLength) {\n  //step 1,2 chaintegrity\n  let power1 = 2n ** (get_t() + get_l());\n  let power2 = 2n ** (2n * keyLength);\n  let Bound = power1 * getK() * getK() * getK() * power2;\n  let r = RandomBnd(Bound);\n  let R1 = PowerMod(vk, delta * r, N * N);\n  let R2 = PowerMod(c, 4n * delta * r, N * N);\n  return [r, R1, R2];\n}\nexport function ZKP_gen_cc(c, ci, vki, R1, R2, vk, N) {\n  // step 4 challange\n  let Bound = 2n ** get_t();\n  //converting the numbers to strings to concatenate them\n  const concatenated = BigInt(c.toString() + ci.toString() + vk.toString() + vki.toString() + R1.toString() + R2.toString());\n  // console.log({ concatenated });\n  //convert the concatenated numbers into hex\n  //The hash function calculates and returns sha256 hash as a string, which we parse\n  // as a BigInt\n  const hashOfConcat = \"0x\" + hash(concatenated.toString(16), \"hex\");\n  console.log({\n    hashOfConcat\n  });\n  let cc = BigInt(hashOfConcat) % N;\n  console.log({\n    cc\n  });\n  return cc;\n}\nexport function ZKP_comput_z(r, cc, fi) {\n  // step 5 response\n  let z = r + cc * fi;\n  return z;\n}\nexport function ZKP_check(c, ci, R1, R2, z, cc, vki, N, delta, vk) {\n  let equality_1_left = PowerMod(vk, delta * z, N * N);\n  let equality_1_right = MulMod(R1, PowerMod(vki, cc, N * N), N * N);\n  let equality_2_left = PowerMod(c, 4n * delta * z, N * N);\n  let equality_2_right = MulMod(R2, PowerMod(ci, 2n * cc, N * N), N * N);\n  let partial_ZKP_check = equality_1_left == equality_1_right && equality_2_left == equality_2_right;\n  return partial_ZKP_check;\n}","map":{"version":3,"sources":["../../src/zkp.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { encrypt } from \".\";\nimport { Gen_Coprime, InvMod, MulMod, PowerMod, RandomBnd } from \"./util\";\nimport { generator } from \"./generator\";\nimport { hash } from \"./hash\";\nimport { get_l, get_t } from \"./t\";\nimport { getK } from \"./K\";\nimport { ethers } from 'ethers';\nexport function createMemberShipZKP(message, validMessages, N, bits = 256n) {\n    const r = Gen_Coprime(N);\n    const cipher = encrypt(message, N, r);\n    const epsilon = Gen_Coprime(N);\n    const ui = PowerMod(epsilon, N, N * N);\n    let i;\n    const us = [], es = [], vs = [];\n    for (const [idx, validMessage] of validMessages.entries()) {\n        //Working variables\n        const gmk = PowerMod(generator(N), validMessage, N * N);\n        const uk = (cipher * InvMod(gmk, N * N)) % (N * N);\n        if (message != validMessage) {\n            //confirm these two\n            //zk\n            const vj = Gen_Coprime(N);\n            //ek\n            const ej = Gen_Coprime(N);\n            const vn = PowerMod(vj, N, N * N);\n            const ue = PowerMod(uk, ej, N * N);\n            const uj = (vn * InvMod(ue, N * N)) % (N * N);\n            us.push(uj);\n            vs.push(vj);\n            es.push(ej);\n        }\n        else {\n            us.push(ui);\n            vs.push(0n);\n            es.push(0n);\n            i = idx;\n        }\n    }\n    const uHash = BigInt(\"0x\" + hash(BigInt(us.join(\"\")).toString(16), \"hex\")) % N;\n    const eSum = es.filter((e) => e != 0n).reduce((acc, e) => (acc + e) % N, 0n);\n    const ei = (uHash - eSum) % N;\n    //Also confirm this\n    const rep = PowerMod(r, ei, N);\n    const vi = (epsilon * rep * PowerMod(generator(N), ei, N)) % N;\n    es[i] = ei;\n    vs[i] = vi;\n    return [cipher, [es, us, vs]];\n}\nexport function computeZKPInputs(ciphertext, \n//[es, us, vs]: [bigint[], bigint[], bigint[]],\nproof, validMessages, N) {\n    const e = BigInt(\"0x\" + hash(BigInt(proof[1].join(\"\")).toString(16), \"hex\")) % N;\n    let ukInv = []; // Array containing the modular inverse of uk for each message.\n    let gmk = [];\n    const as = validMessages.map((m) => {\n        const _gmk = PowerMod(generator(N), m, N * N);\n        gmk.push(ethers.utils.hexlify(_gmk));\n        const uk = (InvMod(_gmk, N * N));\n        const _uk = (ciphertext * InvMod(_gmk, N * N)) % (N * N);\n        const uki = InvMod(_uk, N * N); // Modular inverse of _uk\n        ukInv.push(ethers.utils.hexlify(uki));\n        return ethers.utils.hexlify(uk);\n    });\n    const isProofONegativ = proof[0].map((e) => {\n        if (e < 0n) {\n            return true;\n        }\n        return false;\n    });\n    const p = proof.map((elem, i) => elem.map((value, j) => {\n        if (value < 0n) {\n            //console.log(`value at index ${i}:${j}`, value);\n            return ethers.utils.hexlify(value * -1n);\n        }\n        return ethers.utils.hexlify(value);\n    }));\n    return {\n        proof: p,\n        isProofONegativ,\n        as,\n        ias: ukInv,\n        gmk,\n        e: ethers.utils.hexlify(e),\n    };\n}\nexport function verifyMembershipZkp(ciphertext, [es, us, vs], validMessages, N) {\n    const e = BigInt(\"0x\" + hash(BigInt(us.join(\"\")).toString(16), \"hex\")) % N;\n    const as = validMessages.map((m) => {\n        const gmk = PowerMod(generator(N), m, N * N);\n        const uk = (ciphertext * InvMod(gmk, N * N)) % (N * N);\n        return uk;\n    });\n    const eSum = es.reduce((acc, e) => (acc + e) % N, 0n);\n    if (eSum != e) {\n        return false;\n    }\n    return vs.every((v, idx) => {\n        const ui = us[idx];\n        const ei = es[idx];\n        const ai = as[idx];\n        const vin = PowerMod(v, N, N * N);\n        const aie = PowerMod(ai, ei, N * N);\n        const uiae = (ui * aie) % (N * N);\n        return vin == uiae;\n    });\n}\nexport function ZKP_gen_R(c, N, vk, delta, keyLength) {\n    //step 1,2 chaintegrity\n    let power1 = 2n ** (get_t() + get_l());\n    let power2 = 2n ** (2n * keyLength);\n    let Bound = power1 * getK() * getK() * getK() * power2;\n    let r = RandomBnd(Bound);\n    let R1 = PowerMod(vk, delta * r, N * N);\n    let R2 = PowerMod(c, 4n * delta * r, N * N);\n    return [r, R1, R2];\n}\nexport function ZKP_gen_cc(c, ci, vki, R1, R2, vk, N) {\n    // step 4 challange\n    let Bound = 2n ** get_t();\n    //converting the numbers to strings to concatenate them\n    const concatenated = BigInt(c.toString() +\n        ci.toString() +\n        vk.toString() +\n        vki.toString() +\n        R1.toString() +\n        R2.toString());\n    // console.log({ concatenated });\n    //convert the concatenated numbers into hex\n    //The hash function calculates and returns sha256 hash as a string, which we parse\n    // as a BigInt\n    const hashOfConcat = \"0x\" + hash(concatenated.toString(16), \"hex\");\n    console.log({ hashOfConcat });\n    let cc = BigInt(hashOfConcat) % N;\n    console.log({ cc });\n    return cc;\n}\nexport function ZKP_comput_z(r, cc, fi) {\n    // step 5 response\n    let z = r + cc * fi;\n    return z;\n}\nexport function ZKP_check(c, ci, R1, R2, z, cc, vki, N, delta, vk) {\n    let equality_1_left = PowerMod(vk, delta * z, N * N);\n    let equality_1_right = MulMod(R1, PowerMod(vki, cc, N * N), N * N);\n    let equality_2_left = PowerMod(c, 4n * delta * z, N * N);\n    let equality_2_right = MulMod(R2, PowerMod(ci, 2n * cc, N * N), N * N);\n    let partial_ZKP_check = equality_1_left == equality_1_right && equality_2_left == equality_2_right;\n    return partial_ZKP_check;\n}\n//# sourceMappingURL=zkp.js.map"]},"metadata":{},"sourceType":"module"}