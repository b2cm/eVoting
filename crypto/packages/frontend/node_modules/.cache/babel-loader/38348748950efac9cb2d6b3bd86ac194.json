{"ast":null,"code":"import { firstValueFrom, map, of, zip } from \"rxjs\";\nimport { coefficient_generation, compute_tuple, Gen_Coprime, InvMod, Jacobi, pick_pq, PowerMod, prime } from \"./util\";\nexport async function RSA_ModulusGeneration(allParties, otherParties, thisPartyNumber, keyLength, firstParty) {\n  //generate or get PP\n  let PP;\n  if (!firstParty) {\n    PP = 0n;\n    const key_len_pow = 2n ** (keyLength - 1n);\n    let PP_ceiling = (3n * 3n * key_len_pow) ** 2n;\n    while (PP <= PP_ceiling) {\n      PP = await prime(5 + 2 * +keyLength.toString());\n    }\n    otherParties.forEach(p => p.send(JSON.stringify({\n      PP: PP.toString()\n    })));\n  } else {\n    const {\n      PP: data\n    } = JSON.parse(await firstValueFrom(firstParty.bufferedMessage$));\n    PP = BigInt(data);\n  }\n  console.log(\"PP=\", PP);\n  //generate N;\n  let generation_done = false;\n  let N;\n  let p;\n  let q;\n  while (!generation_done) {\n    p = pick_pq(thisPartyNumber, keyLength);\n    q = pick_pq(thisPartyNumber, keyLength);\n    console.log({\n      p,\n      q\n    });\n    const coeffs = coefficient_generation(PP, allParties.length);\n    let selfTuple;\n    //distribute shares to the other parties\n    for (const party of allParties) {\n      const t = compute_tuple(BigInt(party.partyNumber), PP, p, q, coeffs);\n      if (party.type == \"other\") {\n        party.party.send(JSON.stringify({\n          tuple: t.map(el => el.toString())\n        }));\n      } else {\n        selfTuple = t;\n      }\n    }\n    //get the shared tuples from other parties\n    const tuples = await firstValueFrom(zip(...otherParties.map(p => p.bufferedMessage$.pipe(map(message => JSON.parse(message).tuple.map(s => BigInt(s))))), of(selfTuple)));\n    let pSum = 0n;\n    let qSum = 0n;\n    let hSum = 0n;\n    for (const [p, q, h] of tuples) {\n      pSum += p;\n      qSum += q;\n      hSum += h;\n    }\n    //@ts-ignore\n    const Ni = (pSum * qSum + hSum) % PP;\n    //Lagrange interpolation at x = 0\n    const interpolation_x = 0n;\n    let numerator = 1n;\n    let denominator = 1n;\n    for (const idx2 of tuples.keys()) {\n      if (idx2 !== thisPartyNumber - 1) {\n        numerator = numerator * (interpolation_x - (BigInt(idx2) + 1n));\n        denominator = denominator * (BigInt(thisPartyNumber - 1) + 1n - (BigInt(idx2) + 1n));\n      }\n    }\n    const Li = numerator / denominator;\n    console.log(\"Li=\", Li);\n    const partyN = Ni * Li;\n    console.log(\"Ni=\", partyN);\n    //broadcast our N to all parties\n    for (const party of otherParties) {\n      party.send(JSON.stringify({\n        Ni: partyN.toString()\n      }));\n    }\n    //wait for other parties to send their N\n    const NVals = await firstValueFrom(zip(...otherParties.map(p => p.bufferedMessage$.pipe(map(e => JSON.parse(e)), map(e => BigInt(e.Ni))))));\n    //generate N from all Nis\n    //@ts-ignore\n    N = [...NVals, partyN].reduce((acc, curr) => acc + curr) % PP;\n    console.log(\"N = \" + N);\n    // for some reason, N can negative, in that case the biprimality check does not work\n    if (N < 0) {\n      continue;\n    }\n    //Biprimality check\n    let Qi_inv;\n    if (firstParty) {\n      const gg = await firstValueFrom(firstParty.bufferedMessage$.pipe(map(e => BigInt(JSON.parse(e).gg))));\n      const Qi = PowerMod(gg, (p + q) / 4n, N);\n      Qi_inv = InvMod(Qi, N);\n    } else {\n      let gg = Gen_Coprime(N);\n      while (Jacobi(gg, N) !== 1) {\n        gg = Gen_Coprime(N);\n      }\n      otherParties.forEach(party => party.send(JSON.stringify({\n        gg: gg.toString()\n      })));\n      Qi_inv = PowerMod(gg,\n      //@ts-ignore\n      (N + 1n - p - q) / 4n, N);\n      console.log(\"Q1=\", Qi_inv);\n    }\n    //send our Qi to other parties\n    otherParties.forEach(party => party.send(JSON.stringify({\n      Qi: Qi_inv.toString()\n    })));\n    //get otherQis\n    const otherQs = await firstValueFrom(zip(...otherParties.map(party => party.bufferedMessage$.pipe(map(e => BigInt(JSON.parse(e).Qi))))));\n    const m = otherQs.reduce((acc, q_inv) => acc * q_inv, Qi_inv);\n    let check = m % N === 1n % N || m % N === -1n % N; // biprimality check\n    generation_done = check;\n    console.log({\n      generation_done\n    });\n  }\n  return [N, p, q];\n}","map":{"version":3,"sources":["../../src/RSA_modulus.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { firstValueFrom, map, of, zip } from \"rxjs\";\nimport { coefficient_generation, compute_tuple, Gen_Coprime, InvMod, Jacobi, pick_pq, PowerMod, prime, } from \"./util\";\nexport async function RSA_ModulusGeneration(allParties, otherParties, thisPartyNumber, keyLength, firstParty) {\n    //generate or get PP\n    let PP;\n    if (!firstParty) {\n        PP = 0n;\n        const key_len_pow = 2n ** (keyLength - 1n);\n        let PP_ceiling = (3n * 3n * key_len_pow) ** 2n;\n        while (PP <= PP_ceiling) {\n            PP = await prime(5 + 2 * +keyLength.toString());\n        }\n        otherParties.forEach((p) => p.send(JSON.stringify({ PP: PP.toString() })));\n    }\n    else {\n        const { PP: data } = JSON.parse(await firstValueFrom(firstParty.bufferedMessage$));\n        PP = BigInt(data);\n    }\n    console.log(\"PP=\", PP);\n    //generate N;\n    let generation_done = false;\n    let N;\n    let p;\n    let q;\n    while (!generation_done) {\n        p = pick_pq(thisPartyNumber, keyLength);\n        q = pick_pq(thisPartyNumber, keyLength);\n        console.log({ p, q });\n        const coeffs = coefficient_generation(PP, allParties.length);\n        let selfTuple;\n        //distribute shares to the other parties\n        for (const party of allParties) {\n            const t = compute_tuple(BigInt(party.partyNumber), PP, p, q, coeffs);\n            if (party.type == \"other\") {\n                party.party.send(JSON.stringify({ tuple: t.map((el) => el.toString()) }));\n            }\n            else {\n                selfTuple = t;\n            }\n        }\n        //get the shared tuples from other parties\n        const tuples = await firstValueFrom(zip(...otherParties.map((p) => p.bufferedMessage$.pipe(map((message) => JSON.parse(message).tuple.map((s) => BigInt(s))))), of(selfTuple)));\n        let pSum = 0n;\n        let qSum = 0n;\n        let hSum = 0n;\n        for (const [p, q, h] of tuples) {\n            pSum += p;\n            qSum += q;\n            hSum += h;\n        }\n        //@ts-ignore\n        const Ni = (pSum * qSum + hSum) % PP;\n        //Lagrange interpolation at x = 0\n        const interpolation_x = 0n;\n        let numerator = 1n;\n        let denominator = 1n;\n        for (const idx2 of tuples.keys()) {\n            if (idx2 !== thisPartyNumber - 1) {\n                numerator = numerator * (interpolation_x - (BigInt(idx2) + 1n));\n                denominator =\n                    denominator *\n                        (BigInt(thisPartyNumber - 1) + 1n - (BigInt(idx2) + 1n));\n            }\n        }\n        const Li = numerator / denominator;\n        console.log(\"Li=\", Li);\n        const partyN = Ni * Li;\n        console.log(\"Ni=\", partyN);\n        //broadcast our N to all parties\n        for (const party of otherParties) {\n            party.send(JSON.stringify({ Ni: partyN.toString() }));\n        }\n        //wait for other parties to send their N\n        const NVals = await firstValueFrom(zip(...otherParties.map((p) => p.bufferedMessage$.pipe(map((e) => JSON.parse(e)), map((e) => BigInt(e.Ni))))));\n        //generate N from all Nis\n        //@ts-ignore\n        N = [...NVals, partyN].reduce((acc, curr) => acc + curr) % PP;\n        console.log(\"N = \" + N);\n        // for some reason, N can negative, in that case the biprimality check does not work\n        if (N < 0) {\n            continue;\n        }\n        //Biprimality check\n        let Qi_inv;\n        if (firstParty) {\n            const gg = await firstValueFrom(firstParty.bufferedMessage$.pipe(map((e) => BigInt(JSON.parse(e).gg))));\n            const Qi = PowerMod(gg, (p + q) / 4n, N);\n            Qi_inv = InvMod(Qi, N);\n        }\n        else {\n            let gg = Gen_Coprime(N);\n            while (Jacobi(gg, N) !== 1) {\n                gg = Gen_Coprime(N);\n            }\n            otherParties.forEach((party) => party.send(JSON.stringify({ gg: gg.toString() })));\n            Qi_inv = PowerMod(gg, \n            //@ts-ignore\n            (N + 1n - p - q) / 4n, N);\n            console.log(\"Q1=\", Qi_inv);\n        }\n        //send our Qi to other parties\n        otherParties.forEach((party) => party.send(JSON.stringify({ Qi: Qi_inv.toString() })));\n        //get otherQis\n        const otherQs = await firstValueFrom(zip(...otherParties.map((party) => party.bufferedMessage$.pipe(map((e) => BigInt(JSON.parse(e).Qi))))));\n        const m = otherQs.reduce((acc, q_inv) => acc * q_inv, Qi_inv);\n        let check = m % N === 1n % N || m % N === -1n % N; // biprimality check\n        generation_done = check;\n        console.log({ generation_done });\n    }\n    return [N, p, q];\n}\n//# sourceMappingURL=RSA_modulus.js.map"]},"metadata":{},"sourceType":"module"}