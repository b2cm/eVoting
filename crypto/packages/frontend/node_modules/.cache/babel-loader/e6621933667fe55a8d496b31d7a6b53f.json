{"ast":null,"code":"import { BITS, BYTES, CURVE, _0n, _1n, _2n, _3n } from \"./constant\";\nimport ModMath from \"./mod-math\";\nconst {\n  mod,\n  invert,\n  sqrt\n} = ModMath;\nimport { toBufferBE } from \"bigint-buffer\";\nimport { bufToBigint } from \"bigint-conversion\";\nfunction ECPointCompress(x, y) {\n  const out = new Uint8Array(BYTES + 1);\n  out[0] = 2 + (y[y.length - 1] & 1);\n  out.set(x, 1);\n  return out;\n}\nexport default class Point {\n  constructor() {\n    this.precomputes = [];\n    //http://hyperelliptic.org/EFD/g1p/auto-shortw.html\n    this.add = p => {\n      const [y1, x1, y2, x2] = [this.y, this.x, p.y, p.x];\n      if (x1 === _0n || y1 === _0n) return p;\n      if (x2 === _0n || y2 === _0n) return this;\n      if (x1 === x2 && y1 === y2) return this.double();\n      if (x1 === x2 && y1 === -y2) return Point.ZERO;\n      /*\n              x3 = (y2-y1)^2 / (x2-x1)^2 - x1 - x2\n              y3 = (2*x1+x2) * (y2-y1) / (x2-x1) - (y2-y1)^3 / (x2-x1)^3 - y1\n          */\n      const rep = mod((y2 - y1) * invert(x2 - x1));\n      const x3 = mod(rep * rep - x1 - x2);\n      const y3 = mod((_2n * x1 + x2) * rep - rep ** _3n - y1);\n      return new Point(x3, y3);\n    };\n    //http://hyperelliptic.org/EFD/g1p/auto-shortw.html\n    this.double = () => {\n      const {\n        x,\n        y\n      } = this;\n      const {\n        a\n      } = CURVE;\n      /*\n              x2 = (3 * x1^2 + a)^2 / (2 * y1)^2 - x1 - x1\n              y2 = (2 * x1 + x1) * (3 * x1^2 + a) / (2 * y1) - (3 * x1^2 + a)^3 / (2 * y1)^3 - y1\n          */\n      const rep1 = mod(_3n * x ** _2n + a);\n      const rep2 = mod(_2n * y);\n      const rep3 = mod(rep1 * invert(rep2));\n      const x2 = rep3 ** _2n - _2n * x;\n      const y2 = _3n * x * rep3 - rep3 ** _3n - y;\n      return new Point(x2, y2);\n    };\n    this.getPrecomputes = () => {\n      if (this.precomputes.length) return this.precomputes;\n      this.precomputes = [];\n      let dbl = this;\n      for (let i = 0; i < BITS; i++) {\n        this.precomputes.push(dbl);\n        dbl = dbl.double();\n      }\n      return this.precomputes;\n    };\n    //https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication\n    this.multiplyCT = n => {\n      let ret = Point.ZERO;\n      let fake = Point.ZERO;\n      const dbls = this.getPrecomputes();\n      for (let i = 0; i < BITS; i++) {\n        if (n & _1n) ret = ret.add(dbls[i]);else fake = fake.add(dbls[i]);\n        n >>= _1n;\n      }\n      return ret;\n    };\n    if (arguments.length === 1) {\n      this._compressed_lazy = arguments.length <= 0 ? undefined : arguments[0];\n    }\n    if (arguments.length === 2) {\n      this._x_lazy = arguments.length <= 0 ? undefined : arguments[0];\n      this._y_lazy = arguments.length <= 1 ? undefined : arguments[1];\n    }\n  }\n  get x() {\n    if (this._x_lazy == null) {\n      if (this._compressed_lazy == null) {\n        throw new Error(\"Invalid State\");\n      }\n      const {\n        x,\n        y\n      } = ECPointDecompress(toBufferBE(this._compressed_lazy, BYTES + 1));\n      this._x_lazy = x;\n      this._y_lazy = y;\n    }\n    return this._x_lazy;\n  }\n  get y() {\n    if (this._y_lazy == null) {\n      if (this._compressed_lazy == null) {\n        throw new Error(\"Invalid State\");\n      }\n      const {\n        x,\n        y\n      } = ECPointDecompress(toBufferBE(this._compressed_lazy, BYTES + 1));\n      this._x_lazy = x;\n      this._y_lazy = y;\n    }\n    return this._y_lazy;\n  }\n  invert() {\n    return Point.fromXYPair(this.x, BigInt(-1) * this.y);\n  }\n  get compressed() {\n    if (this._compressed_lazy == null) {\n      this._compressed_lazy = bufToBigint(ECPointCompress(new Uint8Array(toBufferBE(this.x, BYTES)), new Uint8Array(toBufferBE(this.y, BYTES))));\n    }\n    return this._compressed_lazy;\n  }\n  static fromXYPair(x, y) {\n    return new Point(x, y);\n  }\n  static fromCompressed(comp) {\n    return new Point(comp);\n  }\n}\nPoint.SECP256K1 = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction ECPointDecompress(comp) {\n  const signY = comp[0] - 2,\n    // This value must be 2 or 3. 4 indicates an uncompressed key, and anything else is invalid.\n    x = comp.subarray(1),\n    // Import x into bigInt library\n    xBig = bufToBigint(x);\n  // y^2 = x^3 + b\n  let y2 = xBig ** _3n + CURVE.b;\n  let y = sqrt(y2);\n  // If the parity doesn't match it's the *other* root\n  if (y % _2n !== BigInt(signY)) {\n    // y = prime - y\n    y = CURVE.P - y;\n  }\n  return {\n    x: xBig,\n    y: y\n  };\n}","map":{"version":3,"sources":["../../../src/point.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { BITS, BYTES, CURVE, _0n, _1n, _2n, _3n } from \"./constant\";\nimport ModMath from \"./mod-math\";\nconst { mod, invert, sqrt } = ModMath;\nimport { toBufferBE } from \"bigint-buffer\";\nimport { bufToBigint } from \"bigint-conversion\";\nfunction ECPointCompress(x, y) {\n    const out = new Uint8Array(BYTES + 1);\n    out[0] = 2 + (y[y.length - 1] & 1);\n    out.set(x, 1);\n    return out;\n}\nexport default class Point {\n    constructor(...args) {\n        this.precomputes = [];\n        //http://hyperelliptic.org/EFD/g1p/auto-shortw.html\n        this.add = (p) => {\n            const [y1, x1, y2, x2] = [this.y, this.x, p.y, p.x];\n            if (x1 === _0n || y1 === _0n)\n                return p;\n            if (x2 === _0n || y2 === _0n)\n                return this;\n            if (x1 === x2 && y1 === y2)\n                return this.double();\n            if (x1 === x2 && y1 === -y2)\n                return Point.ZERO;\n            /*\n                    x3 = (y2-y1)^2 / (x2-x1)^2 - x1 - x2\n                    y3 = (2*x1+x2) * (y2-y1) / (x2-x1) - (y2-y1)^3 / (x2-x1)^3 - y1\n                */\n            const rep = mod((y2 - y1) * invert(x2 - x1));\n            const x3 = mod(rep * rep - x1 - x2);\n            const y3 = mod((_2n * x1 + x2) * rep - rep ** _3n - y1);\n            return new Point(x3, y3);\n        };\n        //http://hyperelliptic.org/EFD/g1p/auto-shortw.html\n        this.double = () => {\n            const { x, y } = this;\n            const { a } = CURVE;\n            /*\n                    x2 = (3 * x1^2 + a)^2 / (2 * y1)^2 - x1 - x1\n                    y2 = (2 * x1 + x1) * (3 * x1^2 + a) / (2 * y1) - (3 * x1^2 + a)^3 / (2 * y1)^3 - y1\n                */\n            const rep1 = mod(_3n * x ** _2n + a);\n            const rep2 = mod(_2n * y);\n            const rep3 = mod(rep1 * invert(rep2));\n            const x2 = rep3 ** _2n - _2n * x;\n            const y2 = _3n * x * rep3 - rep3 ** _3n - y;\n            return new Point(x2, y2);\n        };\n        this.getPrecomputes = () => {\n            if (this.precomputes.length)\n                return this.precomputes;\n            this.precomputes = [];\n            let dbl = this;\n            for (let i = 0; i < BITS; i++) {\n                this.precomputes.push(dbl);\n                dbl = dbl.double();\n            }\n            return this.precomputes;\n        };\n        //https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication\n        this.multiplyCT = (n) => {\n            let ret = Point.ZERO;\n            let fake = Point.ZERO;\n            const dbls = this.getPrecomputes();\n            for (let i = 0; i < BITS; i++) {\n                if (n & _1n)\n                    ret = ret.add(dbls[i]);\n                else\n                    fake = fake.add(dbls[i]);\n                n >>= _1n;\n            }\n            return ret;\n        };\n        if (args.length === 1) {\n            this._compressed_lazy = args[0];\n        }\n        if (args.length === 2) {\n            this._x_lazy = args[0];\n            this._y_lazy = args[1];\n        }\n    }\n    get x() {\n        if (this._x_lazy == null) {\n            if (this._compressed_lazy == null) {\n                throw new Error(\"Invalid State\");\n            }\n            const { x, y } = ECPointDecompress(toBufferBE(this._compressed_lazy, BYTES + 1));\n            this._x_lazy = x;\n            this._y_lazy = y;\n        }\n        return this._x_lazy;\n    }\n    get y() {\n        if (this._y_lazy == null) {\n            if (this._compressed_lazy == null) {\n                throw new Error(\"Invalid State\");\n            }\n            const { x, y } = ECPointDecompress(toBufferBE(this._compressed_lazy, BYTES + 1));\n            this._x_lazy = x;\n            this._y_lazy = y;\n        }\n        return this._y_lazy;\n    }\n    invert() {\n        return Point.fromXYPair(this.x, BigInt(-1) * this.y);\n    }\n    get compressed() {\n        if (this._compressed_lazy == null) {\n            this._compressed_lazy = bufToBigint(ECPointCompress(new Uint8Array(toBufferBE(this.x, BYTES)), new Uint8Array(toBufferBE(this.y, BYTES))));\n        }\n        return this._compressed_lazy;\n    }\n    static fromXYPair(x, y) {\n        return new Point(x, y);\n    }\n    static fromCompressed(comp) {\n        return new Point(comp);\n    }\n}\nPoint.SECP256K1 = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction ECPointDecompress(comp) {\n    const signY = comp[0] - 2, // This value must be 2 or 3. 4 indicates an uncompressed key, and anything else is invalid.\n    x = comp.subarray(1), \n    // Import x into bigInt library\n    xBig = bufToBigint(x);\n    // y^2 = x^3 + b\n    let y2 = xBig ** _3n + CURVE.b;\n    let y = sqrt(y2);\n    // If the parity doesn't match it's the *other* root\n    if (y % _2n !== BigInt(signY)) {\n        // y = prime - y\n        y = CURVE.P - y;\n    }\n    return {\n        x: xBig,\n        y: y,\n    };\n}\n//# sourceMappingURL=point.js.map"]},"metadata":{},"sourceType":"module"}