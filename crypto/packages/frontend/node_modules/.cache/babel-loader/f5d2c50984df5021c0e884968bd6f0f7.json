{"ast":null,"code":"import { firstValueFrom, lastValueFrom, map, zip } from \"rxjs\";\nimport { generator } from \"./generator\";\nimport { getK } from \"./K\";\nimport { RSA_ModulusGeneration } from \"./RSA_modulus\";\nimport { evaluate_polynomial, factorial, generate_polynomial, Gen_Coprime, PowerMod, RandomBnd } from \"./util\";\nexport * from \"./zkp\";\nexport * from \"./decrypt\";\nexport function encrypt(message, N, r) {\n  let random = r || Gen_Coprime(N);\n  let ciphertext = PowerMod(generator(N), message, N * N) * PowerMod(random, N, N * N);\n  return ciphertext % (N * N);\n}\nexport function combineCiphertext(existing, c) {\n  return existing * c;\n}\nexport async function startGeneration(userId, parties) {\n  let keyLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16n;\n  let threshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n  const allParties = [...parties.map(p => ({\n    type: \"other\",\n    party: p\n  })), {\n    party: {\n      partyId: userId\n    },\n    type: \"this\"\n  }].sort((_ref, _ref2) => {\n    let {\n      party: a\n    } = _ref;\n    let {\n      party: b\n    } = _ref2;\n    return a.partyId.localeCompare(b.partyId);\n  }).map((partyType, idx) => ({\n    partyNumber: idx + 1,\n    ...partyType\n  }));\n  const otherParties = allParties.filter(party => party.party.partyId !== userId).map(party => party.party);\n  const firstParty = allParties[0].type == \"other\" ? allParties[0].party : null;\n  const thisPartyNumber = allParties.find(p => p.party.partyId === userId).partyNumber;\n  console.log({\n    thisPartyNumber\n  });\n  const [N, p, q] = await RSA_ModulusGeneration(allParties, otherParties, thisPartyNumber, keyLength, firstParty);\n  const delta = factorial(allParties.length);\n  const K = getK();\n  let modulus_KN = K * N;\n  let modulus_KKN = K * K * N;\n  //broadcase sum of p and q to all parties\n  otherParties.forEach(party => party.send(JSON.stringify({\n    pqSum: (p + q).toString()\n  })));\n  //get pqSums of other parties\n  const pqSums = await firstValueFrom(zip(...otherParties.map(party => party.bufferedMessage$.pipe(map(e => BigInt(JSON.parse(e).pqSum))))));\n  const phi = N + 1n - pqSums.reduce((acc, sum) => acc + sum, p + q);\n  console.log(\"phi=\", phi);\n  const beta = RandomBnd(modulus_KN);\n  const r = RandomBnd(modulus_KKN);\n  const r_delta = delta * r;\n  const myTheta = delta * phi * beta + N * delta * r;\n  //broadcast theta to all parties\n  otherParties.forEach(party => party.send(JSON.stringify({\n    theta: myTheta.toString()\n  })));\n  //get thetas of other parties\n  const otherThetas = await firstValueFrom(zip(...otherParties.map(party => party.bufferedMessage$.pipe(map(e => BigInt(JSON.parse(e).theta))))));\n  const theta = otherThetas.reduce((sum, t) => sum + t, myTheta);\n  console.log(\"theta=\", theta);\n  //Ri sharing\n  const coeff = generate_polynomial(threshold, modulus_KKN);\n  //distribute shares of our r_delta to all parties\n  const ourShare = r_delta + evaluate_polynomial(coeff, BigInt(thisPartyNumber));\n  for (const party of allParties) {\n    const val = r_delta + evaluate_polynomial(coeff, BigInt(party.partyNumber));\n    if (party.type == \"other\") {\n      party.party.send(JSON.stringify({\n        r_delta: val.toString()\n      }));\n    }\n  }\n  //get shares of other parties r_deltas\n  const other_r_deltas = await lastValueFrom(zip(...otherParties.map(party => party.bufferedMessage$.pipe(map(e => BigInt(JSON.parse(e).r_delta))))));\n  const R = other_r_deltas.reduce((sum, share) => sum + share, ourShare);\n  const f = N * R - theta;\n  console.log({\n    f\n  });\n  let vk;\n  if (!firstParty) {\n    vk = PowerMod(Gen_Coprime(N * N), 2n, N * N);\n    otherParties.forEach(party => party.send(JSON.stringify({\n      vk: vk.toString()\n    })));\n  } else {\n    vk = await firstValueFrom(firstParty.bufferedMessage$.pipe(map(e => BigInt(JSON.parse(e).vk))));\n  }\n  console.log({\n    vk\n  });\n  const vki = PowerMod(vk, delta * f, N * N);\n  console.log({\n    vki\n  });\n  return {\n    public: {\n      N,\n      theta,\n      delta,\n      vk\n    },\n    private: {\n      f,\n      vki\n    },\n    isFirstParty: !firstParty,\n    allParties: allParties.map(p => ({\n      id: p.party.partyId,\n      number: p.partyNumber\n    }))\n  };\n}","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { firstValueFrom, lastValueFrom, map, zip } from \"rxjs\";\nimport { generator } from \"./generator\";\nimport { getK } from \"./K\";\nimport { RSA_ModulusGeneration } from \"./RSA_modulus\";\nimport { evaluate_polynomial, factorial, generate_polynomial, Gen_Coprime, PowerMod, RandomBnd, } from \"./util\";\nexport * from \"./zkp\";\nexport * from \"./decrypt\";\nexport function encrypt(message, N, r) {\n    let random = r || Gen_Coprime(N);\n    let ciphertext = (PowerMod(generator(N), message, N * N) *\n        PowerMod(random, N, N * N));\n    return ciphertext % (N * N);\n}\nexport function combineCiphertext(existing, c) {\n    return existing * c;\n}\nexport async function startGeneration(userId, parties, keyLength = 16n, threshold = 2) {\n    const allParties = [\n        ...parties.map((p) => ({ type: \"other\", party: p })),\n        { party: { partyId: userId }, type: \"this\" },\n    ]\n        .sort(({ party: a }, { party: b }) => a.partyId.localeCompare(b.partyId))\n        .map((partyType, idx) => ({ partyNumber: idx + 1, ...partyType }));\n    const otherParties = allParties\n        .filter((party) => party.party.partyId !== userId)\n        .map((party) => party.party);\n    const firstParty = allParties[0].type == \"other\" ? allParties[0].party : null;\n    const thisPartyNumber = allParties.find((p) => p.party.partyId === userId).partyNumber;\n    console.log({ thisPartyNumber });\n    const [N, p, q] = await RSA_ModulusGeneration(allParties, otherParties, thisPartyNumber, keyLength, firstParty);\n    const delta = factorial(allParties.length);\n    const K = getK();\n    let modulus_KN = K * N;\n    let modulus_KKN = K * K * N;\n    //broadcase sum of p and q to all parties\n    otherParties.forEach((party) => party.send(JSON.stringify({ pqSum: (p + q).toString() })));\n    //get pqSums of other parties\n    const pqSums = await firstValueFrom(zip(...otherParties.map((party) => party.bufferedMessage$.pipe(map((e) => BigInt(JSON.parse(e).pqSum))))));\n    const phi = N + 1n - pqSums.reduce((acc, sum) => acc + sum, p + q);\n    console.log(\"phi=\", phi);\n    const beta = RandomBnd(modulus_KN);\n    const r = RandomBnd(modulus_KKN);\n    const r_delta = delta * r;\n    const myTheta = delta * phi * beta + N * delta * r;\n    //broadcast theta to all parties\n    otherParties.forEach((party) => party.send(JSON.stringify({ theta: myTheta.toString() })));\n    //get thetas of other parties\n    const otherThetas = await firstValueFrom(zip(...otherParties.map((party) => party.bufferedMessage$.pipe(map((e) => BigInt(JSON.parse(e).theta))))));\n    const theta = otherThetas.reduce((sum, t) => sum + t, myTheta);\n    console.log(\"theta=\", theta);\n    //Ri sharing\n    const coeff = generate_polynomial(threshold, modulus_KKN);\n    //distribute shares of our r_delta to all parties\n    const ourShare = r_delta + evaluate_polynomial(coeff, BigInt(thisPartyNumber));\n    for (const party of allParties) {\n        const val = r_delta + evaluate_polynomial(coeff, BigInt(party.partyNumber));\n        if (party.type == \"other\") {\n            party.party.send(JSON.stringify({ r_delta: val.toString() }));\n        }\n    }\n    //get shares of other parties r_deltas\n    const other_r_deltas = await lastValueFrom(zip(...otherParties.map((party) => party.bufferedMessage$.pipe(map((e) => BigInt(JSON.parse(e).r_delta))))));\n    const R = other_r_deltas.reduce((sum, share) => sum + share, ourShare);\n    const f = N * R - theta;\n    console.log({ f });\n    let vk;\n    if (!firstParty) {\n        vk = PowerMod(Gen_Coprime(N * N), 2n, N * N);\n        otherParties.forEach((party) => party.send(JSON.stringify({ vk: vk.toString() })));\n    }\n    else {\n        vk = await firstValueFrom(firstParty.bufferedMessage$.pipe(map((e) => BigInt(JSON.parse(e).vk))));\n    }\n    console.log({ vk });\n    const vki = PowerMod(vk, delta * f, N * N);\n    console.log({ vki });\n    return {\n        public: {\n            N,\n            theta,\n            delta,\n            vk,\n        },\n        private: {\n            f,\n            vki,\n        },\n        isFirstParty: !firstParty,\n        allParties: allParties.map((p) => ({\n            id: p.party.partyId,\n            number: p.partyNumber,\n        })),\n    };\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}