{"ast":null,"code":"import Point from \"./src/point\";\nimport { BITS, CURVE, _1n, _2n, _3n } from \"./src/constant\";\nimport { bufToBigint } from \"bigint-conversion\";\nimport CryptoJS from \"crypto-js\";\n// import { toBigIntBE } from \"bigint-buffer\";\nimport ModMath from \"./src/mod-math\";\nexport { Point };\nexport { CURVE };\nexport * from \"./src/constant\";\nexport const Generator = Point.SECP256K1;\nconst {\n  n\n} = CURVE;\nexport function GenerateRandom() {\n  let num = n + _1n;\n  const _crypto = typeof window === \"undefined\" ? require(\"crypto\").webcrypto : window.crypto;\n  const array = new Uint8Array(BITS / 8);\n  while (num > n) {\n    num = bufToBigint(_crypto.getRandomValues(array));\n  }\n  return num;\n}\nexport function GenPublicKey(priv_key) {\n  return Generator.multiplyCT(priv_key);\n}\nexport function ElgammalEncrypt(pubkey, msg) {\n  // K=kP\n  const EphemeralKey = GenerateRandom();\n  const K = Generator.multiplyCT(EphemeralKey);\n  //C= kA+M\n  const kA = pubkey.multiplyCT(EphemeralKey);\n  const C = msg.add(kA);\n  //console.log(\"c2===\", c2.toString(16));\n  return [K, C];\n}\nexport function signature(message, privkey) {\n  // random integer k in [1, n-1]\n  const k = GenerateRandom();\n  // compute point (x1, y1) = kG\n  const R = Generator.multiplyCT(k);\n  // compute x1 mod n\n  const x1 = R.x;\n  const r = x1 % n;\n  // compute e = H(m) using SHA-256\n  const e = CryptoJS.SHA256(message).toString(CryptoJS.enc.Hex);\n  // convert e to bigint\n  // compute s = k^-1(e + x1*d) mod n\n  const invertedK = ModMath.invert(k, n);\n  const s = invertedK * (BigInt(\"0x\" + e) + r * privkey) % n;\n  return [R, s, BigInt(\"0x\" + e)];\n}\nexport function verifySignature(s, R, e, publicKey) {\n  // verify that s is in [1, n-1]\n  if (s < _1n || s > n - _1n) {\n    throw new Error(\"Invalid signature s\");\n  }\n  // check if R is a valid point on the curve through equation y^2 = x^3 + 7\n  const {\n    x,\n    y\n  } = R;\n  const left = ModMath.pow(y, _2n);\n  const right = ModMath.pow(x, _3n) + CURVE.b;\n  console.log(\"left = \", left.toString(16));\n  console.log(\"right = \", right.toString(16));\n  if (left !== right) {\n    throw new Error(\"Invalid signature R\");\n  }\n  // compute V1 = sR\n  const V1 = R.multiplyCT(s);\n  // compute V2 = eG\n  const hashMul = Generator.multiplyCT(e);\n  const rA = publicKey.multiplyCT(R.x);\n  const V2 = hashMul.add(rA);\n  console.log(\"V1 = \", V1.x.toString(16), V1.y.toString(16));\n  console.log(\"V2 = \", V2.x.toString(16), V2.y.toString(16));\n  return V1.x === V2.x && V1.y === V2.y;\n}\n// export function stringifyCompressed([])\nexport function ElgammalDecrypt(privkey, K, C) {\n  //S=aK\n  const S = K.multiplyCT(privkey);\n  //M=C-S\n  return C.add(S.invert());\n}","map":{"version":3,"sources":["../../index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import Point from \"./src/point\";\nimport { BITS, CURVE, _1n, _2n, _3n } from \"./src/constant\";\nimport { bufToBigint } from \"bigint-conversion\";\nimport CryptoJS from \"crypto-js\";\n// import { toBigIntBE } from \"bigint-buffer\";\nimport ModMath from \"./src/mod-math\";\nexport { Point };\nexport { CURVE };\nexport * from \"./src/constant\";\nexport const Generator = Point.SECP256K1;\nconst { n } = CURVE;\nexport function GenerateRandom() {\n    let num = n + _1n;\n    const _crypto = typeof window === \"undefined\" ? require(\"crypto\").webcrypto : window.crypto;\n    const array = new Uint8Array(BITS / 8);\n    while (num > n) {\n        num = bufToBigint(_crypto.getRandomValues(array));\n    }\n    return num;\n}\nexport function GenPublicKey(priv_key) {\n    return Generator.multiplyCT(priv_key);\n}\nexport function ElgammalEncrypt(pubkey, msg) {\n    // K=kP\n    const EphemeralKey = GenerateRandom();\n    const K = Generator.multiplyCT(EphemeralKey);\n    //C= kA+M\n    const kA = pubkey.multiplyCT(EphemeralKey);\n    const C = msg.add(kA);\n    //console.log(\"c2===\", c2.toString(16));\n    return [K, C];\n}\nexport function signature(message, privkey) {\n    // random integer k in [1, n-1]\n    const k = GenerateRandom();\n    // compute point (x1, y1) = kG\n    const R = Generator.multiplyCT(k);\n    // compute x1 mod n\n    const x1 = R.x;\n    const r = x1 % n;\n    // compute e = H(m) using SHA-256\n    const e = CryptoJS.SHA256(message).toString(CryptoJS.enc.Hex);\n    // convert e to bigint\n    // compute s = k^-1(e + x1*d) mod n\n    const invertedK = ModMath.invert(k, n);\n    const s = (invertedK * (BigInt(\"0x\" + e) + r * privkey)) % n;\n    return [R, s, BigInt(\"0x\" + e)];\n}\nexport function verifySignature(s, R, e, publicKey) {\n    // verify that s is in [1, n-1]\n    if (s < _1n || s > n - _1n) {\n        throw new Error(\"Invalid signature s\");\n    }\n    // check if R is a valid point on the curve through equation y^2 = x^3 + 7\n    const { x, y } = R;\n    const left = ModMath.pow(y, _2n);\n    const right = ModMath.pow(x, _3n) + CURVE.b;\n    console.log(\"left = \", left.toString(16));\n    console.log(\"right = \", right.toString(16));\n    if (left !== right) {\n        throw new Error(\"Invalid signature R\");\n    }\n    // compute V1 = sR\n    const V1 = R.multiplyCT(s);\n    // compute V2 = eG\n    const hashMul = Generator.multiplyCT(e);\n    const rA = publicKey.multiplyCT(R.x);\n    const V2 = hashMul.add(rA);\n    console.log(\"V1 = \", V1.x.toString(16), V1.y.toString(16));\n    console.log(\"V2 = \", V2.x.toString(16), V2.y.toString(16));\n    return V1.x === V2.x && V1.y === V2.y;\n}\n// export function stringifyCompressed([])\nexport function ElgammalDecrypt(privkey, K, C) {\n    //S=aK\n    const S = K.multiplyCT(privkey);\n    //M=C-S\n    return C.add(S.invert());\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}