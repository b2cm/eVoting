{"ast":null,"code":"import { firstValueFrom, map, of, zip } from \"rxjs\";\nimport { ZKP_check, ZKP_comput_z, ZKP_gen_cc, ZKP_gen_R } from \".\";\nimport { InvMod, MulMod, PowerMod } from \"./util\";\nfunction partialDecrypt(ciphertext, N, fi, delta) {\n  return PowerMod(ciphertext, 2n * delta * fi, N * N);\n}\nexport async function decrypt(ciphertext, userId, parties, partyNumbers, N, delta, theta, vk, fi, vki, candidates) {\n  let keyLength = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 16n;\n  let threshold = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 2;\n  const partial_dec_res = partialDecrypt(ciphertext, N, fi, delta);\n  const allParties = [...parties.map(p => ({\n    type: \"other\",\n    party: p\n  })), {\n    party: {\n      partyId: userId\n    },\n    type: \"this\"\n  }].sort((_ref, _ref2) => {\n    let {\n      party: a\n    } = _ref;\n    let {\n      party: b\n    } = _ref2;\n    return a.partyId.localeCompare(b.partyId);\n  }).map((partyType, idx) => ({\n    partyNumber: idx + 1,\n    ...partyType\n  }));\n  const otherParties = allParties.filter(party => party.party.partyId !== userId).map(party => party.party);\n  //generate zkp\n  const [r, R1, R2] = ZKP_gen_R(ciphertext, N, vk, delta, keyLength);\n  let cc = ZKP_gen_cc(ciphertext, partial_dec_res, vki, R1, R2, vk, N);\n  let z = ZKP_comput_z(r, cc, fi);\n  //broadcast zkp and partial decryption to all parties\n  otherParties.forEach(party => {\n    party.send(JSON.stringify({\n      partial_dec_res: partial_dec_res.toString(),\n      R1: R1.toString(),\n      R2: R2.toString(),\n      z: z.toString(),\n      cc: cc.toString(),\n      vki: vki.toString()\n    }));\n  });\n  const otherZkps = await firstValueFrom(zip(...allParties.map(party => party.type == \"other\" ? party.party.bufferedMessage$.pipe(map(e => {\n    const obj = JSON.parse(e);\n    return {\n      partial_dec_res: BigInt(obj.partial_dec_res),\n      R1: BigInt(obj.R1),\n      R2: BigInt(obj.R2),\n      z: BigInt(obj.z),\n      cc: BigInt(obj.cc),\n      vki: BigInt(obj.vki),\n      partyNumber: partyNumbers.find(_ref3 => {\n        let {\n          id\n        } = _ref3;\n        return id === party.party.partyId;\n      }).number\n    };\n  })) : of({\n    partial_dec_res: partial_dec_res,\n    R1: R1,\n    R2: R2,\n    z: z,\n    cc: cc,\n    vki: vki,\n    partyNumber: partyNumbers.find(_ref4 => {\n      let {\n        id\n      } = _ref4;\n      return id === party.party.partyId;\n    }).number\n  }))));\n  const validParties = otherZkps.map(_ref5 => {\n    let {\n      partial_dec_res,\n      R1,\n      R2,\n      z,\n      cc,\n      vki,\n      partyNumber\n    } = _ref5;\n    console.log('proof decryption', {\n      ciphertext,\n      partial_dec_res,\n      R1,\n      R2,\n      z,\n      cc,\n      vki,\n      N,\n      delta,\n      vk\n    });\n    const valid = ZKP_check(ciphertext, partial_dec_res, R1, R2, z, cc, vki, N, delta, vk);\n    return {\n      valid,\n      partyNumber,\n      partial_dec_res\n    };\n  }).filter(_ref6 => {\n    let {\n      valid\n    } = _ref6;\n    return valid;\n  });\n  if (validParties.length <= threshold) {\n    throw new Error(\"Not enough parties available for decryption\");\n  }\n  //combine partial decryptions\n  const dec = combine_partial_decrypt(validParties.map(_ref7 => {\n    let {\n      partial_dec_res,\n      partyNumber\n    } = _ref7;\n    return [partyNumber - 1, partial_dec_res];\n  }), N, delta, theta);\n  console.log(dec);\n  //get tallies\n  let curr = dec;\n  let tallies = [];\n  for (const cand of candidates.sort((b, a) => a < b ? -1 : a > b ? 1 : 0)) {\n    const votes = curr / cand;\n    tallies.push({\n      candidate: cand,\n      votes\n    });\n    curr = curr % cand;\n  }\n  return tallies;\n}\nfunction combine_partial_decrypt(partial_decrypt_results, N, delta, theta) {\n  const lambdas = [];\n  //Lagrange interpolation at x = 0\n  const interpolation_x = 0n;\n  for (const [idx1] of partial_decrypt_results) {\n    let numerator = 1n;\n    let denominator = 1n;\n    for (const [idx2] of partial_decrypt_results) {\n      if (idx2 != idx1) {\n        numerator = numerator * (interpolation_x - (BigInt(idx2) + 1n));\n        denominator = denominator * (BigInt(idx1) + 1n - (BigInt(idx2) + 1n));\n      }\n    }\n    lambdas.push([numerator, denominator]);\n  }\n  // these u-values are present in the library, but are never used...\n  // let u1 = this.delta * lambda1;\n  // let u2 = this.delta * lambda2;\n  // let u3 = this.delta * lambda3;\n  let products = partial_decrypt_results.map((_ref8, idx) => {\n    let [, c] = _ref8;\n    return PowerMod(c, 2n * delta * lambdas[idx][0] / lambdas[idx][1], N * N);\n  });\n  let product = products.reduce((acc, p) => acc * p, 1n) % (N * N);\n  let Inv_temp = InvMod(-4n * delta * delta * theta % N, N);\n  let M = MulMod(L_function(product, N), Inv_temp, N);\n  return M;\n}\nfunction L_function(x, N) {\n  return (x - 1n) / N;\n}","map":{"version":3,"sources":["../../src/decrypt.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { firstValueFrom, map, of, zip } from \"rxjs\";\nimport { ZKP_check, ZKP_comput_z, ZKP_gen_cc, ZKP_gen_R } from \".\";\nimport { InvMod, MulMod, PowerMod } from \"./util\";\nfunction partialDecrypt(ciphertext, N, fi, delta) {\n    return PowerMod(ciphertext, 2n * delta * fi, N * N);\n}\nexport async function decrypt(ciphertext, userId, parties, partyNumbers, N, delta, theta, vk, fi, vki, candidates, keyLength = 16n, threshold = 2) {\n    const partial_dec_res = partialDecrypt(ciphertext, N, fi, delta);\n    const allParties = [\n        ...parties.map((p) => ({ type: \"other\", party: p })),\n        { party: { partyId: userId }, type: \"this\" },\n    ]\n        .sort(({ party: a }, { party: b }) => a.partyId.localeCompare(b.partyId))\n        .map((partyType, idx) => ({ partyNumber: idx + 1, ...partyType }));\n    const otherParties = allParties\n        .filter((party) => party.party.partyId !== userId)\n        .map((party) => party.party);\n    //generate zkp\n    const [r, R1, R2] = ZKP_gen_R(ciphertext, N, vk, delta, keyLength);\n    let cc = ZKP_gen_cc(ciphertext, partial_dec_res, vki, R1, R2, vk, N);\n    let z = ZKP_comput_z(r, cc, fi);\n    //broadcast zkp and partial decryption to all parties\n    otherParties.forEach((party) => {\n        party.send(JSON.stringify({\n            partial_dec_res: partial_dec_res.toString(),\n            R1: R1.toString(),\n            R2: R2.toString(),\n            z: z.toString(),\n            cc: cc.toString(),\n            vki: vki.toString(),\n        }));\n    });\n    const otherZkps = await firstValueFrom(zip(...allParties.map((party) => party.type == \"other\"\n        ? party.party.bufferedMessage$.pipe(map((e) => {\n            const obj = JSON.parse(e);\n            return {\n                partial_dec_res: BigInt(obj.partial_dec_res),\n                R1: BigInt(obj.R1),\n                R2: BigInt(obj.R2),\n                z: BigInt(obj.z),\n                cc: BigInt(obj.cc),\n                vki: BigInt(obj.vki),\n                partyNumber: partyNumbers.find(({ id }) => id === party.party.partyId).number,\n            };\n        }))\n        : of({\n            partial_dec_res: partial_dec_res,\n            R1: R1,\n            R2: R2,\n            z: z,\n            cc: cc,\n            vki: vki,\n            partyNumber: partyNumbers.find(({ id }) => id === party.party.partyId).number,\n        }))));\n    const validParties = otherZkps\n        .map(({ partial_dec_res, R1, R2, z, cc, vki, partyNumber }) => {\n        console.log('proof decryption', {\n            ciphertext,\n            partial_dec_res,\n            R1,\n            R2,\n            z,\n            cc,\n            vki,\n            N,\n            delta,\n            vk\n        });\n        const valid = ZKP_check(ciphertext, partial_dec_res, R1, R2, z, cc, vki, N, delta, vk);\n        return { valid, partyNumber, partial_dec_res };\n    })\n        .filter(({ valid }) => valid);\n    if (validParties.length <= threshold) {\n        throw new Error(\"Not enough parties available for decryption\");\n    }\n    //combine partial decryptions\n    const dec = combine_partial_decrypt(validParties.map(({ partial_dec_res, partyNumber }) => [\n        partyNumber - 1,\n        partial_dec_res,\n    ]), N, delta, theta);\n    console.log(dec);\n    //get tallies\n    let curr = dec;\n    let tallies = [];\n    for (const cand of candidates.sort((b, a) => (a < b ? -1 : a > b ? 1 : 0))) {\n        const votes = curr / cand;\n        tallies.push({\n            candidate: cand,\n            votes,\n        });\n        curr = curr % cand;\n    }\n    return tallies;\n}\nfunction combine_partial_decrypt(partial_decrypt_results, N, delta, theta) {\n    const lambdas = [];\n    //Lagrange interpolation at x = 0\n    const interpolation_x = 0n;\n    for (const [idx1] of partial_decrypt_results) {\n        let numerator = 1n;\n        let denominator = 1n;\n        for (const [idx2] of partial_decrypt_results) {\n            if (idx2 != idx1) {\n                numerator = numerator * (interpolation_x - (BigInt(idx2) + 1n));\n                denominator = denominator * (BigInt(idx1) + 1n - (BigInt(idx2) + 1n));\n            }\n        }\n        lambdas.push([numerator, denominator]);\n    }\n    // these u-values are present in the library, but are never used...\n    // let u1 = this.delta * lambda1;\n    // let u2 = this.delta * lambda2;\n    // let u3 = this.delta * lambda3;\n    let products = partial_decrypt_results.map(([, c], idx) => PowerMod(c, (2n * delta * lambdas[idx][0]) / lambdas[idx][1], N * N));\n    let product = products.reduce((acc, p) => acc * p, 1n) % (N * N);\n    let Inv_temp = InvMod((-4n * delta * delta * theta) % N, N);\n    let M = MulMod(L_function(product, N), Inv_temp, N);\n    return M;\n}\nfunction L_function(x, N) {\n    return (x - 1n) / N;\n}\n//# sourceMappingURL=decrypt.js.map"]},"metadata":{},"sourceType":"module"}